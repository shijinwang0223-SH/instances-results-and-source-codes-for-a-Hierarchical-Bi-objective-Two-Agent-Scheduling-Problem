{\rtf1\ansi\ansicpg1252\cocoartf2639
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;\f1\fnil\fcharset0 Menlo-Bold;}
{\colortbl;\red255\green255\blue255;\red93\green108\blue121;\red255\green255\blue255;\red0\green0\blue0;
\red100\green56\blue32;\red196\green26\blue22;\red155\green35\blue147;\red57\green0\blue160;\red11\green79\blue121;
\red28\green0\blue207;\red15\green104\blue160;\red108\green54\blue169;\red28\green70\blue74;\red50\green109\blue116;
}
{\*\expandedcolortbl;;\csgenericrgb\c36526\c42188\c47515;\csgenericrgb\c100000\c100000\c100000;\csgenericrgb\c0\c0\c0\c85000;
\csgenericrgb\c39147\c22031\c12446;\csgenericrgb\c77000\c10200\c8600;\csgenericrgb\c60759\c13753\c57628;\csgenericrgb\c22454\c0\c62803;\csgenericrgb\c4314\c30980\c47451;
\csgenericrgb\c11000\c0\c81000;\csgenericrgb\c5882\c40784\c62745;\csgenericrgb\c42190\c21278\c66379;\csgenericrgb\c10981\c27276\c28869;\csgenericrgb\c19418\c42935\c45455;
}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\deftab593
\pard\tx593\pardeftab593\pardirnatural\partightenfactor0

\f0\fs24 \cf2 \cb3 /*\cf4 \
\cf2   compare_7methods.cpp\cf4 \
\cf2   ------------------------------------------------------------\cf4 \
\cf2   CPLEX 12.7 + Xcode 14.2 (clang++)\cf4 \
\cf2   Seven methods compared (lex objective with fixed U_min):\cf4 \
\cf2     (1) MIP-P\cf4 \
\cf2     (2) MIP-P + VI (VI1..VI5)\cf4 \
\cf2     (3) TwoStage(P) exact (master over z, subproblem MIP-P fixed-z)\cf4 \
\cf2     (4) TwoStage(P)+VI exact (master has VI3..VI5 + lazy feasibility cuts; subproblem has VI1..VI2)\cf4 \
\cf2     (5) MIP-T2\cf4 \
\cf2     (6) MIP-T2 + VI (VI3..VI5 + TI-safe tightening)\cf4 \
\cf2     (7) Heuristic AB improved (signed tardy build + pattern LS + tardy LS)\cf4 \
\
\cf2   Critical correctness points:\cf4 \
\cf2     - ALL methods enforce sum_j z_j == U_min  (NOT <=)\cf4 \
\cf2     - TwoStage is exhaustive enumeration of feasible z patterns.\cf4 \
\cf2     - No "value cuts" of eta(z) are used (NOT generally valid).\cf4 \
\cf2 */\cf4 \
\
\cf5 #include \cf6 <ilcplex/ilocplex.h>\cf4 \
\cf5 #include \cf6 <algorithm>\cf4 \
\cf5 #include \cf6 <chrono>\cf4 \
\cf5 #include \cf6 <cmath>\cf4 \
\cf5 #include \cf6 <cstdint>\cf4 \
\cf5 #include \cf6 <fstream>\cf4 \
\cf5 #include \cf6 <iomanip>\cf4 \
\cf5 #include \cf6 <iostream>\cf4 \
\cf5 #include \cf6 <limits>\cf4 \
\cf5 #include \cf6 <map>\cf4 \
\cf5 #include \cf6 <numeric>\cf4 \
\cf5 #include \cf6 <random>\cf4 \
\cf5 #include \cf6 <sstream>\cf4 \
\cf5 #include \cf6 <string>\cf4 \
\cf5 #include \cf6 <unordered_map>\cf4 \
\cf5 #include \cf6 <unordered_set>\cf4 \
\cf5 #include \cf6 <vector>\cf4 \
\cf5 #include \cf6 <thread>\cf4 \
\cf5 ILOSTLBEGIN\cf4 \

\f1\b \cf7 using
\f0\b0 \cf4  
\f1\b \cf7 namespace
\f0\b0 \cf4  \cf8 std\cf4 ;\
\
\cf2 // ============================ Data structures ============================\cf4 \

\f1\b \cf7 struct
\f0\b0 \cf4  \cf9 Job\cf4  \{\
    
\f1\b \cf7 int
\f0\b0 \cf4  id;\
    
\f1\b \cf7 int
\f0\b0 \cf4  agent; \cf2 // 0=A, 1=B\cf4 \
    
\f1\b \cf7 int
\f0\b0 \cf4  p;\
    
\f1\b \cf7 int
\f0\b0 \cf4  d;\
    
\f1\b \cf7 int
\f0\b0 \cf4  w;\
\};\
\

\f1\b \cf7 struct
\f0\b0 \cf4  \cf9 SolveInfo\cf4  \{\
    
\f1\b \cf7 bool
\f0\b0 \cf4  feasible = 
\f1\b \cf7 false
\f0\b0 \cf4 ;\
    \cf8 string\cf4  status = \cf6 "NA"\cf4 ;\
    
\f1\b \cf7 double
\f0\b0 \cf4  obj = -\cf10 1.0\cf4 ;      \cf2 // eta = |wTA - wTB|\cf4 \
    
\f1\b \cf7 double
\f0\b0 \cf4  time = \cf10 0.0\cf4 ;\
    
\f1\b \cf7 double
\f0\b0 \cf4  gap = \cf10 0.0\cf4 ;\
    
\f1\b \cf7 double
\f0\b0 \cf4  wTA = \cf10 0.0\cf4 ;\
    
\f1\b \cf7 double
\f0\b0 \cf4  wTB = \cf10 0.0\cf4 ;\
    \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > seq;\
    \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > z;\
    
\f1\b \cf7 int
\f0\b0 \cf4  iters = \cf10 0\cf4 ;\
    
\f1\b \cf7 int
\f0\b0 \cf4  cuts = \cf10 0\cf4 ;\
\};\
\
\cf2 // ============================ Timing helpers ============================\cf4 \

\f1\b \cf7 static
\f0\b0 \cf4  
\f1\b \cf7 inline
\f0\b0 \cf4  
\f1\b \cf7 double
\f0\b0 \cf4  \cf11 nowSec\cf4 () \{\
    
\f1\b \cf7 using
\f0\b0 \cf4  
\f1\b \cf7 namespace
\f0\b0 \cf4  \cf8 chrono\cf4 ;\
    
\f1\b \cf7 return
\f0\b0 \cf4  \cf8 duration\cf4 <
\f1\b \cf7 double
\f0\b0 \cf4 >(\cf8 high_resolution_clock\cf4 ::\cf12 now\cf4 ().\cf12 time_since_epoch\cf4 ()).\cf12 count\cf4 ();\
\}\
\

\f1\b \cf7 static
\f0\b0 \cf4  \cf8 string\cf4  \cf11 statusToString\cf4 (\cf13 IloCplex\cf4 & cplex) \{\
    \cf13 IloAlgorithm\cf4 ::\cf13 Status\cf4  st = cplex.\cf14 getStatus\cf4 ();\
    
\f1\b \cf7 switch
\f0\b0 \cf4  (st) \{\
        
\f1\b \cf7 case
\f0\b0 \cf4  \cf13 IloAlgorithm\cf4 ::\cf14 Optimal\cf4 : 
\f1\b \cf7 return
\f0\b0 \cf4  \cf6 "Optimal"\cf4 ;\
        
\f1\b \cf7 case
\f0\b0 \cf4  \cf13 IloAlgorithm\cf4 ::\cf14 Feasible\cf4 : 
\f1\b \cf7 return
\f0\b0 \cf4  \cf6 "Feasible"\cf4 ;\
        
\f1\b \cf7 case
\f0\b0 \cf4  \cf13 IloAlgorithm\cf4 ::\cf14 Infeasible\cf4 : 
\f1\b \cf7 return
\f0\b0 \cf4  \cf6 "Infeasible"\cf4 ;\
        
\f1\b \cf7 case
\f0\b0 \cf4  \cf13 IloAlgorithm\cf4 ::\cf14 Unbounded\cf4 : 
\f1\b \cf7 return
\f0\b0 \cf4  \cf6 "Unbounded"\cf4 ;\
        
\f1\b \cf7 case
\f0\b0 \cf4  \cf13 IloAlgorithm\cf4 ::\cf14 InfeasibleOrUnbounded\cf4 : 
\f1\b \cf7 return
\f0\b0 \cf4  \cf6 "InfOrUnb"\cf4 ;\
        
\f1\b \cf7 case
\f0\b0 \cf4  \cf13 IloAlgorithm\cf4 ::\cf14 Error\cf4 : 
\f1\b \cf7 return
\f0\b0 \cf4  \cf6 "Error"\cf4 ;\
        
\f1\b \cf7 default
\f0\b0 \cf4 : 
\f1\b \cf7 return
\f0\b0 \cf4  \cf6 "Other"\cf4 ;\
    \}\
\}\
\

\f1\b \cf7 static
\f0\b0 \cf4  
\f1\b \cf7 double
\f0\b0 \cf4  \cf11 safeGap\cf4 (\cf13 IloCplex\cf4 & cplex) \{\
    
\f1\b \cf7 try
\f0\b0 \cf4  \{\
        
\f1\b \cf7 if
\f0\b0 \cf4  (cplex.\cf14 getStatus\cf4 () == \cf13 IloAlgorithm\cf4 ::\cf14 Optimal\cf4 ) 
\f1\b \cf7 return
\f0\b0 \cf4  \cf10 0.0\cf4 ;\
        
\f1\b \cf7 if
\f0\b0 \cf4  (cplex.\cf14 getStatus\cf4 () == \cf13 IloAlgorithm\cf4 ::\cf14 Feasible\cf4 ) 
\f1\b \cf7 return
\f0\b0 \cf4  cplex.\cf14 getMIPRelativeGap\cf4 ();\
    \} 
\f1\b \cf7 catch
\f0\b0 \cf4  (...) \{\}\
    
\f1\b \cf7 return
\f0\b0 \cf4  \cf10 0.0\cf4 ;\
\}\
\
\cf2 // ============================ TF/RDD instance generation ============================\cf4 \

\f1\b \cf7 static
\f0\b0 \cf4  \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > \cf11 genProcessingTimes\cf4 (
\f1\b \cf7 int
\f0\b0 \cf4  n, \cf8 mt19937\cf4 & rng) \{\
    \cf8 uniform_int_distribution\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > p_dist(\cf10 1\cf4 , \cf10 100\cf4 );\
    \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > p(n);\
    
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  i = \cf10 0\cf4 ; i < n; ++i) p[i] = p_dist(rng);\
    
\f1\b \cf7 return
\f0\b0 \cf4  p;\
\}\
\

\f1\b \cf7 static
\f0\b0 \cf4  \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > \cf11 genWeights\cf4 (
\f1\b \cf7 int
\f0\b0 \cf4  n, \cf8 mt19937\cf4 & rng) \{\
    \cf8 uniform_int_distribution\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > w_dist(\cf10 1\cf4 , \cf10 10\cf4 );\
    \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > w(n);\
    
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  i = \cf10 0\cf4 ; i < n; ++i) w[i] = w_dist(rng);\
    
\f1\b \cf7 return
\f0\b0 \cf4  w;\
\}\
\
\cf2 // Classical TF/RDD due date generator\cf4 \
\cf2 // d_j ~ U[ P*(1-TF-RDD/2), P*(1-TF+RDD/2) ], clipped into [0, P]\cf4 \

\f1\b \cf7 static
\f0\b0 \cf4  \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > \cf11 genDueDates_TF_RDD\cf4 (
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 >& p, 
\f1\b \cf7 double
\f0\b0 \cf4  TF, 
\f1\b \cf7 double
\f0\b0 \cf4  RDD, \cf8 mt19937\cf4 & rng) \{\
    
\f1\b \cf7 int
\f0\b0 \cf4  P = \cf12 accumulate\cf4 (p.\cf12 begin\cf4 (), p.\cf12 end\cf4 (), \cf10 0\cf4 );\
    
\f1\b \cf7 double
\f0\b0 \cf4  center = (
\f1\b \cf7 double
\f0\b0 \cf4 )P * (\cf10 1.0\cf4  - TF);\
    
\f1\b \cf7 double
\f0\b0 \cf4  half   = (
\f1\b \cf7 double
\f0\b0 \cf4 )P * (RDD / \cf10 2.0\cf4 );\
    
\f1\b \cf7 int
\f0\b0 \cf4  L = (
\f1\b \cf7 int
\f0\b0 \cf4 )\cf12 floor\cf4 (center - half);\
    
\f1\b \cf7 int
\f0\b0 \cf4  U = (
\f1\b \cf7 int
\f0\b0 \cf4 )\cf12 ceil\cf4 (center + half);\
    L = \cf12 max\cf4 (L, \cf10 0\cf4 );\
    U = \cf12 min\cf4 (U, P);\
    
\f1\b \cf7 if
\f0\b0 \cf4  (L > U) \cf12 swap\cf4 (L, U);\
    \cf2 //[0, 0.5P]\cf4 \
   \cf2 // L=0;\cf4 \
   \cf2 // U=0.3*P;\cf4 \
    \cf8 uniform_int_distribution\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > d_dist(L, U);\
\
    \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > d(p.\cf12 size\cf4 ());\
    
\f1\b \cf7 for
\f0\b0 \cf4  (\cf8 size_t\cf4  i = \cf10 0\cf4 ; i < p.\cf12 size\cf4 (); ++i) d[i] = d_dist(rng);\
    
\f1\b \cf7 return
\f0\b0 \cf4  d;\
\}\
\

\f1\b \cf7 static
\f0\b0 \cf4  \cf8 vector\cf4 <\cf13 Job\cf4 > \cf11 generateInstance_TF_RDD\cf4 (
\f1\b \cf7 int
\f0\b0 \cf4  n, 
\f1\b \cf7 int
\f0\b0 \cf4  seed, 
\f1\b \cf7 double
\f0\b0 \cf4  TF, 
\f1\b \cf7 double
\f0\b0 \cf4  RDD) \{\
    \cf8 mt19937\cf4  rng(seed);\
    \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > p = \cf14 genProcessingTimes\cf4 (n, rng);\
    \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > w = \cf14 genWeights\cf4 (n, rng);\
    \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > d = \cf14 genDueDates_TF_RDD\cf4 (p, TF, RDD, rng);\
\
    \cf8 vector\cf4 <\cf13 Job\cf4 > jobs;\
    jobs.\cf12 reserve\cf4 (n);\
    
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  i = \cf10 0\cf4 ; i < n; ++i) \{\
        \cf13 Job\cf4  jb;\
        jb.\cf14 id\cf4  = i;\
        jb.\cf14 agent\cf4  = (i < n/\cf10 2\cf4 ) ? \cf10 0\cf4  : \cf10 1\cf4 ;\
        \cf2 //i<n/5\cf4 \
      \cf2 //  jb.agent = (i < n/5) ? 0 : 1;\cf4 \
        jb.\cf14 p\cf4  = p[i];\
        jb.\cf14 d\cf4  = d[i];\
        jb.\cf14 w\cf4  = w[i];\
        jobs.\cf12 push_back\cf4 (jb);\
    \}\
    
\f1\b \cf7 return
\f0\b0 \cf4  jobs;\
\}\
\

\f1\b \cf7 static
\f0\b0 \cf4  
\f1\b \cf7 void
\f0\b0 \cf4  \cf11 saveInstanceCSV\cf4 (
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 string\cf4 & path, 
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 vector\cf4 <\cf13 Job\cf4 >& jobs) \{\
    \cf8 ofstream\cf4  f(path.\cf12 c_str\cf4 ());\
    f << \cf6 "ID,Agent,p,d,w\\n"\cf4 ;\
    
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 auto
\f0\b0 \cf4 & jb : jobs) \{\
        f << jb.\cf14 id\cf4  << \cf6 ","\cf4  << jb.\cf14 agent\cf4  << \cf6 ","\cf4  << jb.\cf14 p\cf4  << \cf6 ","\cf4  << jb.\cf14 d\cf4  << \cf6 ","\cf4  << jb.\cf14 w\cf4  << \cf6 "\\n"\cf4 ;\
    \}\
\}\
\
\cf2 // ============================ Evaluate a sequence ============================\cf4 \

\f1\b \cf7 static
\f0\b0 \cf4  \cf13 SolveInfo\cf4  \cf11 evalSequence\cf4 (
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 vector\cf4 <\cf13 Job\cf4 >& jobs, 
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 >& seq) \{\
    
\f1\b \cf7 int
\f0\b0 \cf4  n = (
\f1\b \cf7 int
\f0\b0 \cf4 )jobs.\cf12 size\cf4 ();\
    \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > C(n, \cf10 0\cf4 );\
    
\f1\b \cf7 int
\f0\b0 \cf4  t = \cf10 0\cf4 ;\
    
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  k = \cf10 0\cf4 ; k < n; k++) \{\
        
\f1\b \cf7 int
\f0\b0 \cf4  j = seq[k];\
        t += jobs[j].\cf14 p\cf4 ;\
        C[j] = t;\
    \}\
    
\f1\b \cf7 int
\f0\b0 \cf4  nA = \cf10 0\cf4 , nB = \cf10 0\cf4 ;\
    
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) (jobs[j].\cf14 agent\cf4  == \cf10 0\cf4  ? nA : nB)++;\
\
    
\f1\b \cf7 double
\f0\b0 \cf4  sumA = \cf10 0.0\cf4 , sumB = \cf10 0.0\cf4 ;\
    \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > z(n, \cf10 0\cf4 );\
    
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) \{\
        
\f1\b \cf7 int
\f0\b0 \cf4  Tj = \cf12 max\cf4 (\cf10 0\cf4 , C[j] - jobs[j].\cf14 d\cf4 );\
        
\f1\b \cf7 if
\f0\b0 \cf4  (C[j] > jobs[j].\cf14 d\cf4 ) z[j] = \cf10 1\cf4 ;\
        
\f1\b \cf7 if
\f0\b0 \cf4  (jobs[j].\cf14 agent\cf4  == \cf10 0\cf4 ) sumA += jobs[j].\cf14 w\cf4  * (
\f1\b \cf7 double
\f0\b0 \cf4 )Tj;\
        
\f1\b \cf7 else
\f0\b0 \cf4  sumB += jobs[j].\cf14 w\cf4  * (
\f1\b \cf7 double
\f0\b0 \cf4 )Tj;\
    \}\
\
    \cf13 SolveInfo\cf4  si;\
    si.\cf14 feasible\cf4  = 
\f1\b \cf7 true
\f0\b0 \cf4 ;\
    si.\cf14 status\cf4  = \cf6 "SEQ"\cf4 ;\
    si.\cf14 seq\cf4  = seq;\
    si.\cf14 z\cf4  = z;\
    si.\cf14 wTA\cf4  = (nA ? sumA / nA : \cf10 0.0\cf4 );\
    si.\cf14 wTB\cf4  = (nB ? sumB / nB : \cf10 0.0\cf4 );\
    si.\cf14 obj\cf4  = \cf12 fabs\cf4 (si.\cf14 wTA\cf4  - si.\cf14 wTB\cf4 );\
    
\f1\b \cf7 return
\f0\b0 \cf4  si;\
\}\
\
\cf2 // Moore algorithm for 1||sum Uj -> provides UB sequence and U_min\cf4 \

\f1\b \cf7 static
\f0\b0 \cf4  \cf8 pair\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 , \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 >> \cf11 mooresAlgorithm\cf4 (
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 vector\cf4 <\cf13 Job\cf4 >& jobs) \{\
    \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > idx(jobs.\cf12 size\cf4 ());\
    \cf12 iota\cf4 (idx.\cf12 begin\cf4 (), idx.\cf12 end\cf4 (), \cf10 0\cf4 );\
    \cf12 sort\cf4 (idx.\cf12 begin\cf4 (), idx.\cf12 end\cf4 (), [&](
\f1\b \cf7 int
\f0\b0 \cf4  a, 
\f1\b \cf7 int
\f0\b0 \cf4  b) \{ 
\f1\b \cf7 return
\f0\b0 \cf4  jobs[a].\cf14 d\cf4  < jobs[b].\cf14 d\cf4 ; \});\
\
    \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > onTime, removed;\
    
\f1\b \cf7 int
\f0\b0 \cf4  t = \cf10 0\cf4 ;\
    
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j : idx) \{\
        onTime.\cf12 push_back\cf4 (j);\
        t += jobs[j].\cf14 p\cf4 ;\
        
\f1\b \cf7 if
\f0\b0 \cf4  (t > jobs[j].\cf14 d\cf4 ) \{\
            
\f1\b \cf7 int
\f0\b0 \cf4  arg = onTime[\cf10 0\cf4 ];\
            
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  u : onTime) 
\f1\b \cf7 if
\f0\b0 \cf4  (jobs[u].\cf14 p\cf4  > jobs[arg].\cf14 p\cf4 ) arg = u;\
            removed.\cf12 push_back\cf4 (arg);\
            t -= jobs[arg].\cf14 p\cf4 ;\
            onTime.\cf12 erase\cf4 (\cf12 remove\cf4 (onTime.\cf12 begin\cf4 (), onTime.\cf12 end\cf4 (), arg), onTime.\cf12 end\cf4 ());\
        \}\
    \}\
    \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > seq;\
    seq.\cf12 insert\cf4 (seq.\cf12 end\cf4 (), onTime.\cf12 begin\cf4 (), onTime.\cf12 end\cf4 ());\
    seq.\cf12 insert\cf4 (seq.\cf12 end\cf4 (), removed.\cf12 begin\cf4 (), removed.\cf12 end\cf4 ());\
    
\f1\b \cf7 return
\f0\b0 \cf4  \cf12 make_pair\cf4 ((
\f1\b \cf7 int
\f0\b0 \cf4 )removed.\cf12 size\cf4 (), seq);\
\}\
\
\cf2 // ============================ Big-M data ============================\cf4 \

\f1\b \cf7 struct
\f0\b0 \cf4  \cf9 BigMData\cf4  \{\
    
\f1\b \cf7 int
\f0\b0 \cf4  P = \cf10 0\cf4 ;\
    
\f1\b \cf7 double
\f0\b0 \cf4  M = \cf10 0.0\cf4 ;\
    \cf8 vector\cf4 <
\f1\b \cf7 double
\f0\b0 \cf4 > Mj;\
    \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > alwaysOnTime; \cf2 // d_j >= P => cannot be tardy\cf4 \
\};\
\

\f1\b \cf7 static
\f0\b0 \cf4  \cf13 BigMData\cf4  \cf11 computeBigM\cf4 (
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 vector\cf4 <\cf13 Job\cf4 >& jobs) \{\
    \cf13 BigMData\cf4  bm;\
    
\f1\b \cf7 int
\f0\b0 \cf4  n = (
\f1\b \cf7 int
\f0\b0 \cf4 )jobs.\cf12 size\cf4 ();\
    bm.\cf14 P\cf4  = \cf10 0\cf4 ;\
    
\f1\b \cf7 int
\f0\b0 \cf4  maxw = \cf10 0\cf4 ;\
    
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) \{ bm.\cf14 P\cf4  += jobs[j].\cf14 p\cf4 ; maxw = \cf12 max\cf4 (maxw, jobs[j].\cf14 w\cf4 ); \}\
    bm.\cf14 M\cf4  = (
\f1\b \cf7 double
\f0\b0 \cf4 )bm.\cf14 P\cf4 ;\
\
    bm.\cf14 Mj\cf4 .\cf12 assign\cf4 (n, \cf10 0.0\cf4 );\
    bm.\cf14 alwaysOnTime\cf4 .\cf12 assign\cf4 (n, \cf10 0\cf4 );\
    
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) \{\
        
\f1\b \cf7 if
\f0\b0 \cf4  (jobs[j].\cf14 d\cf4  >= bm.\cf14 P\cf4 ) \{\
            bm.\cf14 alwaysOnTime\cf4 [j] = \cf10 1\cf4 ;\
            bm.\cf12 Mj\cf4 [j] = \cf10 0.0\cf4 ;\
        \} 
\f1\b \cf7 else
\f0\b0 \cf4  \{\
            bm.\cf14 alwaysOnTime\cf4 [j] = \cf10 0\cf4 ;\
            bm.\cf12 Mj\cf4 [j] = \cf12 max\cf4 (\cf10 1.0\cf4 , (
\f1\b \cf7 double
\f0\b0 \cf4 )bm.\cf14 P\cf4  - (
\f1\b \cf7 double
\f0\b0 \cf4 )jobs[j].\cf14 d\cf4 );\
        \}\
    \}\
    
\f1\b \cf7 return
\f0\b0 \cf4  bm;\
\}\
\
\cf2 // Safe global upper bound on eta: maxw * P\cf4 \

\f1\b \cf7 static
\f0\b0 \cf4  
\f1\b \cf7 double
\f0\b0 \cf4  \cf11 computeEtaUpperBound\cf4 (
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 vector\cf4 <\cf13 Job\cf4 >& jobs) \{\
    
\f1\b \cf7 int
\f0\b0 \cf4  P = \cf10 0\cf4 , maxw = \cf10 0\cf4 ;\
    
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 auto
\f0\b0 \cf4 & jb : jobs) \{ P += jb.\cf14 p\cf4 ; maxw = \cf12 max\cf4 (maxw, jb.\cf14 w\cf4 ); \}\
    
\f1\b \cf7 return
\f0\b0 \cf4  (
\f1\b \cf7 double
\f0\b0 \cf4 )maxw * (
\f1\b \cf7 double
\f0\b0 \cf4 )P + \cf10 1.0\cf4 ;\
\}\
\
\cf2 // ============================ Shared modeling helpers ============================\cf4 \

\f1\b \cf7 static
\f0\b0 \cf4  
\f1\b \cf7 void
\f0\b0 \cf4  \cf11 addEtaConstraints\cf4 (\cf13 IloEnv\cf4 & env, \cf13 IloModel\cf4 & model, 
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 vector\cf4 <\cf13 Job\cf4 >& jobs,\
                              
\f1\b \cf7 const
\f0\b0 \cf4  \cf13 IloNumVarArray\cf4 & T, \cf13 IloNumVar\cf4 & eta)\
\{\
    
\f1\b \cf7 int
\f0\b0 \cf4  n = (
\f1\b \cf7 int
\f0\b0 \cf4 )jobs.\cf12 size\cf4 ();\
    
\f1\b \cf7 int
\f0\b0 \cf4  nA = \cf10 0\cf4 , nB = \cf10 0\cf4 ;\
    
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) (jobs[j].\cf14 agent\cf4  == \cf10 0\cf4  ? nA : nB)++;\
\
    \cf13 IloExpr\cf4  diff(env);\
    
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) \{\
        
\f1\b \cf7 double
\f0\b0 \cf4  coeff = (jobs[j].\cf14 agent\cf4  == \cf10 0\cf4  ? (
\f1\b \cf7 double
\f0\b0 \cf4 )jobs[j].\cf14 w\cf4  / (
\f1\b \cf7 double
\f0\b0 \cf4 )nA : -(
\f1\b \cf7 double
\f0\b0 \cf4 )jobs[j].\cf14 w\cf4  / (
\f1\b \cf7 double
\f0\b0 \cf4 )nB);\
        diff += coeff * T[j];\
    \}\
    model.\cf14 add\cf4 (eta >= diff);\
    model.\cf14 add\cf4 (eta >= -diff);\
    diff.\cf14 end\cf4 ();\
\}\
\

\f1\b \cf7 static
\f0\b0 \cf4  
\f1\b \cf7 void
\f0\b0 \cf4  \cf11 extractSeqFromX\cf4 (\cf13 IloCplex\cf4 & cplex, 
\f1\b \cf7 const
\f0\b0 \cf4  \cf13 IloArray\cf4 <\cf13 IloBoolVarArray\cf4 >& x, \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 >& seqOut) \{\
    
\f1\b \cf7 int
\f0\b0 \cf4  n = (
\f1\b \cf7 int
\f0\b0 \cf4 )seqOut.\cf12 size\cf4 ();\
    
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  k = \cf10 0\cf4 ; k < n; k++) \{\
        seqOut[k] = -\cf10 1\cf4 ;\
        
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) \{\
            
\f1\b \cf7 if
\f0\b0 \cf4  (cplex.\cf14 getValue\cf4 (x[\cf14 j\cf4 ][k]) > \cf10 0.5\cf4 ) \{ seqOut[k] = j; 
\f1\b \cf7 break
\f0\b0 \cf4 ; \}\
        \}\
    \}\
\}\
\
\cf2 // ============================ VI flags ============================\cf4 \

\f1\b \cf7 struct
\f0\b0 \cf4  \cf9 VIFlags\cf4  \{\
    
\f1\b \cf7 bool
\f0\b0 \cf4  VI1_prefix_S_lb = 
\f1\b \cf7 true
\f0\b0 \cf4 ;        \cf2 // S[k] >= sum of k smallest p\cf4 \
    
\f1\b \cf7 bool
\f0\b0 \cf4  VI2_sym_identical = 
\f1\b \cf7 true
\f0\b0 \cf4 ;      \cf2 // identical jobs symmetry breaking\cf4 \
    
\f1\b \cf7 bool
\f0\b0 \cf4  VI3_edd_prefix_cover = 
\f1\b \cf7 true
\f0\b0 \cf4 ;   \cf2 // global EDD prefix => at least 1 tardy\cf4 \
    
\f1\b \cf7 bool
\f0\b0 \cf4  VI4_capacity_deadlines = 
\f1\b \cf7 true
\f0\b0 \cf4 ; \cf2 // sum p(1-z) <= D for jobs with d<=D\cf4 \
    
\f1\b \cf7 bool
\f0\b0 \cf4  VI5_pairwise = 
\f1\b \cf7 true
\f0\b0 \cf4 ;           \cf2 // if two can't both be on-time => z_i+z_j>=1\cf4 \
\};\
\

\f1\b \cf7 static
\f0\b0 \cf4  
\f1\b \cf7 void
\f0\b0 \cf4  \cf11 addVI_MIP_P\cf4 (\cf13 IloEnv\cf4 & env, \cf13 IloModel\cf4 & model, 
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 vector\cf4 <\cf13 Job\cf4 >& jobs,\
                       
\f1\b \cf7 const
\f0\b0 \cf4  \cf13 IloArray\cf4 <\cf13 IloBoolVarArray\cf4 >& x, 
\f1\b \cf7 const
\f0\b0 \cf4  \cf13 IloNumVarArray\cf4 & S,\
                       
\f1\b \cf7 const
\f0\b0 \cf4  \cf13 IloBoolVarArray\cf4 & z, 
\f1\b \cf7 const
\f0\b0 \cf4  \cf13 VIFlags\cf4 & f)\
\{\
    
\f1\b \cf7 int
\f0\b0 \cf4  n = (
\f1\b \cf7 int
\f0\b0 \cf4 )jobs.\cf12 size\cf4 ();\
\
    
\f1\b \cf7 if
\f0\b0 \cf4  (f.\cf14 VI1_prefix_S_lb\cf4 ) \{\
        \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > ps(n);\
        
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) ps[j] = jobs[j].\cf14 p\cf4 ;\
        \cf12 sort\cf4 (ps.\cf12 begin\cf4 (), ps.\cf12 end\cf4 ());\
        
\f1\b \cf7 int
\f0\b0 \cf4  run = \cf10 0\cf4 ;\
        
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  k = \cf10 0\cf4 ; k < n; k++) \{\
            run += ps[k];\
            model.\cf14 add\cf4 (S[k] >= run);\
        \}\
    \}\
\
    
\f1\b \cf7 if
\f0\b0 \cf4  (f.\cf14 VI2_sym_identical\cf4 ) \{\
        
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  i = \cf10 0\cf4 ; i < n; i++) \{\
            
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = i + \cf10 1\cf4 ; j < n; j++) \{\
                
\f1\b \cf7 if
\f0\b0 \cf4  (jobs[i].\cf14 agent\cf4  == jobs[j].\cf14 agent\cf4  &&\
                    jobs[i].\cf14 p\cf4  == jobs[j].\cf14 p\cf4  &&\
                    jobs[i].\cf14 d\cf4  == jobs[j].\cf14 d\cf4  &&\
                    jobs[i].\cf14 w\cf4  == jobs[j].\cf14 w\cf4 )\
                \{\
                    \cf13 IloExpr\cf4  posi(env), posj(env);\
                    
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  k = \cf10 0\cf4 ; k < n; k++) \{\
                        posi += (k + \cf10 1\cf4 ) * x[\cf14 i\cf4 ][k];\
                        posj += (k + \cf10 1\cf4 ) * x[\cf14 j\cf4 ][k];\
                    \}\
                    model.\cf14 add\cf4 (posi <= posj);\
                    posi.\cf14 end\cf4 (); posj.\cf14 end\cf4 ();\
                \}\
            \}\
        \}\
    \}\
\
    \cf2 // VI3..VI5 are constraints in z\cf4 \
    
\f1\b \cf7 if
\f0\b0 \cf4  (f.\cf14 VI3_edd_prefix_cover\cf4 ) \{\
        \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > idx(n);\
        \cf12 iota\cf4 (idx.\cf12 begin\cf4 (), idx.\cf12 end\cf4 (), \cf10 0\cf4 );\
        \cf12 sort\cf4 (idx.\cf12 begin\cf4 (), idx.\cf12 end\cf4 (), [&](
\f1\b \cf7 int
\f0\b0 \cf4  a, 
\f1\b \cf7 int
\f0\b0 \cf4  b)\{ 
\f1\b \cf7 return
\f0\b0 \cf4  jobs[a].\cf14 d\cf4  < jobs[b].\cf14 d\cf4 ; \});\
\
        
\f1\b \cf7 int
\f0\b0 \cf4  sumP = \cf10 0\cf4 ;\
        
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  r = \cf10 0\cf4 ; r < n; r++) \{\
            sumP += jobs[idx[\cf12 r\cf4 ]].\cf14 p\cf4 ;\
            
\f1\b \cf7 if
\f0\b0 \cf4  (sumP > jobs[idx[\cf12 r\cf4 ]].\cf14 d\cf4 ) \{\
                \cf13 IloExpr\cf4  cover(env);\
                
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  i = \cf10 0\cf4 ; i <= r; i++) cover += z[idx[\cf14 i\cf4 ]];\
                model.\cf14 add\cf4 (cover >= \cf10 1\cf4 );\
                cover.\cf14 end\cf4 ();\
            \}\
        \}\
    \}\
\
    
\f1\b \cf7 if
\f0\b0 \cf4  (f.\cf14 VI4_capacity_deadlines\cf4 ) \{\
        \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > Ds;\
        Ds.\cf12 reserve\cf4 (n);\
        
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) Ds.\cf12 push_back\cf4 (jobs[j].\cf14 d\cf4 );\
        \cf12 sort\cf4 (Ds.\cf12 begin\cf4 (), Ds.\cf12 end\cf4 ());\
        Ds.\cf12 erase\cf4 (\cf12 unique\cf4 (Ds.\cf12 begin\cf4 (), Ds.\cf12 end\cf4 ()), Ds.\cf12 end\cf4 ());\
\
        
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  D : Ds) \{\
            \cf13 IloExpr\cf4  cap(env);\
            
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) 
\f1\b \cf7 if
\f0\b0 \cf4  (jobs[j].\cf14 d\cf4  <= D) cap += jobs[j].\cf14 p\cf4  * (\cf10 1\cf4  - z[j]);\
            model.\cf14 add\cf4 (cap <= D);\
            cap.\cf14 end\cf4 ();\
        \}\
    \}\
\
    
\f1\b \cf7 if
\f0\b0 \cf4  (f.\cf14 VI5_pairwise\cf4 ) \{\
        
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  i = \cf10 0\cf4 ; i < n; i++) 
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = i+\cf10 1\cf4 ; j < n; j++) \{\
            
\f1\b \cf7 if
\f0\b0 \cf4  (jobs[i].\cf14 p\cf4  + jobs[j].\cf14 p\cf4  > \cf12 max\cf4 (jobs[i].\cf14 d\cf4 , jobs[j].\cf14 d\cf4 )) model.\cf14 add\cf4 (z[i] + z[j] >= \cf10 1\cf4 );\
        \}\
    \}\
\}\
\

\f1\b \cf7 static
\f0\b0 \cf4  
\f1\b \cf7 void
\f0\b0 \cf4  \cf11 addVI_Zonly\cf4 (\cf13 IloEnv\cf4 & env, \cf13 IloModel\cf4 & model, 
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 vector\cf4 <\cf13 Job\cf4 >& jobs, 
\f1\b \cf7 const
\f0\b0 \cf4  \cf13 IloBoolVarArray\cf4 & z, 
\f1\b \cf7 const
\f0\b0 \cf4  \cf13 VIFlags\cf4 & f) \{\
    
\f1\b \cf7 int
\f0\b0 \cf4  n = (
\f1\b \cf7 int
\f0\b0 \cf4 )jobs.\cf12 size\cf4 ();\
\
    
\f1\b \cf7 if
\f0\b0 \cf4  (f.\cf14 VI3_edd_prefix_cover\cf4 ) \{\
        \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > idx(n);\
        \cf12 iota\cf4 (idx.\cf12 begin\cf4 (), idx.\cf12 end\cf4 (), \cf10 0\cf4 );\
        \cf12 sort\cf4 (idx.\cf12 begin\cf4 (), idx.\cf12 end\cf4 (), [&](
\f1\b \cf7 int
\f0\b0 \cf4  a, 
\f1\b \cf7 int
\f0\b0 \cf4  b)\{ 
\f1\b \cf7 return
\f0\b0 \cf4  jobs[a].\cf14 d\cf4  < jobs[b].\cf14 d\cf4 ; \});\
\
        
\f1\b \cf7 int
\f0\b0 \cf4  sumP = \cf10 0\cf4 ;\
        
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  r = \cf10 0\cf4 ; r < n; r++) \{\
            sumP += jobs[idx[\cf12 r\cf4 ]].\cf14 p\cf4 ;\
            
\f1\b \cf7 if
\f0\b0 \cf4  (sumP > jobs[idx[\cf12 r\cf4 ]].\cf14 d\cf4 ) \{\
                \cf13 IloExpr\cf4  cover(env);\
                
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  i = \cf10 0\cf4 ; i <= r; i++) cover += z[idx[\cf14 i\cf4 ]];\
                model.\cf14 add\cf4 (cover >= \cf10 1\cf4 );\
                cover.\cf14 end\cf4 ();\
            \}\
        \}\
    \}\
\
    
\f1\b \cf7 if
\f0\b0 \cf4  (f.\cf14 VI4_capacity_deadlines\cf4 ) \{\
        \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > Ds;\
        Ds.\cf12 reserve\cf4 (n);\
        
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) Ds.\cf12 push_back\cf4 (jobs[j].\cf14 d\cf4 );\
        \cf12 sort\cf4 (Ds.\cf12 begin\cf4 (), Ds.\cf12 end\cf4 ());\
        Ds.\cf12 erase\cf4 (\cf12 unique\cf4 (Ds.\cf12 begin\cf4 (), Ds.\cf12 end\cf4 ()), Ds.\cf12 end\cf4 ());\
\
        
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  D : Ds) \{\
            \cf13 IloExpr\cf4  cap(env);\
            
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) 
\f1\b \cf7 if
\f0\b0 \cf4  (jobs[j].\cf14 d\cf4  <= D) cap += jobs[j].\cf14 p\cf4  * (\cf10 1\cf4  - z[j]);\
            model.\cf14 add\cf4 (cap <= D);\
            cap.\cf14 end\cf4 ();\
        \}\
    \}\
\
    
\f1\b \cf7 if
\f0\b0 \cf4  (f.\cf14 VI5_pairwise\cf4 ) \{\
        
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  i = \cf10 0\cf4 ; i < n; i++) 
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = i+\cf10 1\cf4 ; j < n; j++) \{\
            
\f1\b \cf7 if
\f0\b0 \cf4  (jobs[i].\cf14 p\cf4  + jobs[j].\cf14 p\cf4  > \cf12 max\cf4 (jobs[i].\cf14 d\cf4 , jobs[j].\cf14 d\cf4 )) model.\cf14 add\cf4 (z[i] + z[j] >= \cf10 1\cf4 );\
        \}\
    \}\
\}\
\
\cf2 // ============================ Feasibility cuts (EDD prefix within on-time set) ============================\cf4 \

\f1\b \cf7 struct
\f0\b0 \cf4  \cf9 CutPrefix\cf4  \{\
    
\f1\b \cf7 int
\f0\b0 \cf4  type = \cf10 1\cf4 ;\
    \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > P;\
    \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > Q; \cf2 // for type2\cf4 \
    
\f1\b \cf7 int
\f0\b0 \cf4  mP = \cf10 1\cf4 ;\
    
\f1\b \cf7 int
\f0\b0 \cf4  Delta = \cf10 0\cf4 ;\
\};\
\

\f1\b \cf7 static
\f0\b0 \cf4  
\f1\b \cf7 bool
\f0\b0 \cf4  \cf11 findViolatedPrefixWithinOnTime\cf4 (
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 vector\cf4 <\cf13 Job\cf4 >& jobs, 
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 >& b, \cf13 CutPrefix\cf4 & cutOut) \{\
    \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > S;\
    
\f1\b \cf7 int
\f0\b0 \cf4  n = (
\f1\b \cf7 int
\f0\b0 \cf4 )jobs.\cf12 size\cf4 ();\
    
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) 
\f1\b \cf7 if
\f0\b0 \cf4  (b[j] == \cf10 0\cf4 ) S.\cf12 push_back\cf4 (j);\
    \cf12 sort\cf4 (S.\cf12 begin\cf4 (), S.\cf12 end\cf4 (), [&](
\f1\b \cf7 int
\f0\b0 \cf4  a, 
\f1\b \cf7 int
\f0\b0 \cf4  c)\{ 
\f1\b \cf7 return
\f0\b0 \cf4  jobs[a].\cf14 d\cf4  < jobs[c].\cf14 d\cf4 ; \});\
\
    
\f1\b \cf7 int
\f0\b0 \cf4  sumP = \cf10 0\cf4 ;\
    
\f1\b \cf7 int
\f0\b0 \cf4  dmax = \cf10 0\cf4 ;\
    \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > prefix;\
    
\f1\b \cf7 for
\f0\b0 \cf4  (\cf8 size_t\cf4  r = \cf10 0\cf4 ; r < S.\cf12 size\cf4 (); r++) \{\
        
\f1\b \cf7 int
\f0\b0 \cf4  j = S[r];\
        prefix.\cf12 push_back\cf4 (j);\
        sumP += jobs[j].\cf14 p\cf4 ;\
        dmax = \cf12 max\cf4 (dmax, jobs[j].\cf14 d\cf4 );\
        
\f1\b \cf7 if
\f0\b0 \cf4  (sumP > dmax) \{\
            cutOut.\cf14 P\cf4  = prefix;\
            cutOut.\cf14 Delta\cf4  = sumP - dmax;\
\
            \cf2 // Q = argmax p\cf4 \
            
\f1\b \cf7 int
\f0\b0 \cf4  pmax = -\cf10 1\cf4 ;\
            cutOut.\cf14 Q\cf4 .\cf12 clear\cf4 ();\
            
\f1\b \cf7 for
\f0\b0 \cf4  (\cf8 size_t\cf4  t = \cf10 0\cf4 ; t < prefix.\cf12 size\cf4 (); t++) \{\
                
\f1\b \cf7 int
\f0\b0 \cf4  jj = prefix[t];\
                
\f1\b \cf7 if
\f0\b0 \cf4  (jobs[jj].\cf14 p\cf4  > pmax) \{ pmax = jobs[jj].\cf14 p\cf4 ; cutOut.\cf14 Q\cf4 .\cf12 clear\cf4 (); cutOut.\cf14 Q\cf4 .\cf12 push_back\cf4 (jj); \}\
                
\f1\b \cf7 else
\f0\b0 \cf4  
\f1\b \cf7 if
\f0\b0 \cf4  (jobs[jj].\cf14 p\cf4  == pmax) cutOut.\cf14 Q\cf4 .\cf12 push_back\cf4 (jj);\
            \}\
\
            \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > ps;\
            
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  jj : prefix) ps.\cf12 push_back\cf4 (jobs[jj].\cf14 p\cf4 );\
            \cf12 sort\cf4 (ps.\cf12 begin\cf4 (), ps.\cf12 end\cf4 (), \cf8 greater\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 >());\
            
\f1\b \cf7 int
\f0\b0 \cf4  removed = \cf10 0\cf4 , remSum = sumP;\
            
\f1\b \cf7 while
\f0\b0 \cf4  (removed < (
\f1\b \cf7 int
\f0\b0 \cf4 )ps.\cf12 size\cf4 () && remSum > dmax) \{ remSum -= ps[removed]; removed++; \}\
            cutOut.\cf14 mP\cf4  = \cf12 max\cf4 (\cf10 1\cf4 , removed);\
            
\f1\b \cf7 return
\f0\b0 \cf4  
\f1\b \cf7 true
\f0\b0 \cf4 ;\
        \}\
    \}\
    
\f1\b \cf7 return
\f0\b0 \cf4  
\f1\b \cf7 false
\f0\b0 \cf4 ;\
\}\
\
\cf2 // ============================ Method 1: MIP-P ============================\cf4 \

\f1\b \cf7 static
\f0\b0 \cf4  
\f1\b \cf7 void
\f0\b0 \cf4  \cf11 addAssignmentAndCumulativeS\cf4 (\cf13 IloEnv\cf4 & env, \cf13 IloModel\cf4 & model, 
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 vector\cf4 <\cf13 Job\cf4 >& jobs,\
                                       \cf13 IloArray\cf4 <\cf13 IloBoolVarArray\cf4 >& x, \cf13 IloNumVarArray\cf4 & S)\
\{\
    
\f1\b \cf7 int
\f0\b0 \cf4  n = (
\f1\b \cf7 int
\f0\b0 \cf4 )jobs.\cf12 size\cf4 ();\
\
    
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  k = \cf10 0\cf4 ; k < n; k++) \{\
        \cf13 IloExpr\cf4  sum(env);\
        
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) sum += x[\cf14 j\cf4 ][k];\
        model.\cf14 add\cf4 (sum == \cf10 1\cf4 );\
        sum.\cf14 end\cf4 ();\
    \}\
    
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) \{\
        \cf13 IloExpr\cf4  sum(env);\
        
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  k = \cf10 0\cf4 ; k < n; k++) sum += x[\cf14 j\cf4 ][k];\
        model.\cf14 add\cf4 (sum == \cf10 1\cf4 );\
        sum.\cf14 end\cf4 ();\
    \}\
\
    \{\
        \cf13 IloExpr\cf4  s0(env);\
        
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) s0 += jobs[j].\cf14 p\cf4  * x[\cf14 j\cf4 ][\cf10 0\cf4 ];\
        model.\cf14 add\cf4 (S[\cf10 0\cf4 ] == s0);\
        s0.\cf14 end\cf4 ();\
    \}\
    
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  k = \cf10 1\cf4 ; k < n; k++) \{\
        \cf13 IloExpr\cf4  sk(env);\
        
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) sk += jobs[j].\cf14 p\cf4  * x[\cf14 j\cf4 ][k];\
        model.\cf14 add\cf4 (S[k] == S[k - \cf10 1\cf4 ] + sk);\
        sk.\cf14 end\cf4 ();\
    \}\
\}\
\

\f1\b \cf7 static
\f0\b0 \cf4  
\f1\b \cf7 void
\f0\b0 \cf4  \cf11 linkCompletionTimes\cf4 (\cf13 IloEnv\cf4 & env, \cf13 IloModel\cf4 & model, 
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 vector\cf4 <\cf13 Job\cf4 >& jobs,\
                               \cf13 IloArray\cf4 <\cf13 IloBoolVarArray\cf4 >& x, 
\f1\b \cf7 const
\f0\b0 \cf4  \cf13 IloNumVarArray\cf4 & S,\
                               \cf13 IloNumVarArray\cf4 & C, 
\f1\b \cf7 double
\f0\b0 \cf4  M)\
\{\
    
\f1\b \cf7 int
\f0\b0 \cf4  n = (
\f1\b \cf7 int
\f0\b0 \cf4 )jobs.\cf12 size\cf4 ();\
    
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) \{\
        
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  k = \cf10 0\cf4 ; k < n; k++) \{\
            model.\cf14 add\cf4 (C[j] >= S[k] - M * (\cf10 1\cf4  - x[\cf14 j\cf4 ][k]));\
            model.\cf14 add\cf4 (C[j] <= S[k] + M * (\cf10 1\cf4  - x[\cf14 j\cf4 ][k]));\
        \}\
    \}\
\}\
\

\f1\b \cf7 static
\f0\b0 \cf4  
\f1\b \cf7 void
\f0\b0 \cf4  \cf11 addTardinessLogic\cf4 (\cf13 IloEnv\cf4 & env, \cf13 IloModel\cf4 & model, 
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 vector\cf4 <\cf13 Job\cf4 >& jobs,\
                             
\f1\b \cf7 const
\f0\b0 \cf4  \cf13 BigMData\cf4 & bm,\
                             \cf13 IloNumVarArray\cf4 & C, \cf13 IloNumVarArray\cf4 & T, \cf13 IloBoolVarArray\cf4 & z)\
\{\
    
\f1\b \cf7 int
\f0\b0 \cf4  n = (
\f1\b \cf7 int
\f0\b0 \cf4 )jobs.\cf12 size\cf4 ();\
    
\f1\b \cf7 double
\f0\b0 \cf4  eps = \cf10 1e-6\cf4 ;\
    
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) \{\
        
\f1\b \cf7 if
\f0\b0 \cf4  (bm.\cf14 alwaysOnTime\cf4 [j]) \{\
            model.\cf14 add\cf4 (z[j] == \cf10 0\cf4 );\
            model.\cf14 add\cf4 (T[j] == \cf10 0\cf4 );\
            model.\cf14 add\cf4 (C[j] <= jobs[j].\cf14 d\cf4 );\
        \} 
\f1\b \cf7 else
\f0\b0 \cf4  \{\
            model.\cf14 add\cf4 (T[j] >= C[j] - jobs[j].\cf14 d\cf4 );\
            model.\cf14 add\cf4 (T[j] >= \cf10 0\cf4 );\
            model.\cf14 add\cf4 (T[j] <= (C[j] - jobs[j].\cf14 d\cf4 ) + bm.\cf14 M\cf4  * (\cf10 1\cf4  - z[j]));\
            model.\cf14 add\cf4 (T[j] <= bm.\cf14 M\cf4  * z[j]);\
            model.\cf14 add\cf4 (C[j] <= jobs[j].\cf14 d\cf4  + bm.\cf14 M\cf4  * z[j]);\
            model.\cf14 add\cf4 (C[j] >= jobs[j].\cf14 d\cf4  - bm.\cf14 M\cf4  * (\cf10 1\cf4  - z[j]));\
            model.\cf14 add\cf4 (C[j] >= jobs[j].\cf14 d\cf4  + eps - bm.\cf14 M\cf4  * (\cf10 1\cf4  - z[j]));\
        \}\
    \}\
\}\
\

\f1\b \cf7 static
\f0\b0 \cf4  \cf13 SolveInfo\cf4  \cf11 solveMIP_P\cf4 (
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 vector\cf4 <\cf13 Job\cf4 >& jobs, 
\f1\b \cf7 int
\f0\b0 \cf4  U_min, 
\f1\b \cf7 double
\f0\b0 \cf4  UB_eta, 
\f1\b \cf7 double
\f0\b0 \cf4  timeLimit, 
\f1\b \cf7 bool
\f0\b0 \cf4  useVI)\
\{\
    \cf13 SolveInfo\cf4  out;\
    
\f1\b \cf7 double
\f0\b0 \cf4  t0 = \cf14 nowSec\cf4 ();\
    
\f1\b \cf7 int
\f0\b0 \cf4  n = (
\f1\b \cf7 int
\f0\b0 \cf4 )jobs.\cf12 size\cf4 ();\
    \cf13 BigMData\cf4  bm = \cf14 computeBigM\cf4 (jobs);\
\
    
\f1\b \cf7 int
\f0\b0 \cf4  mustOnTime = \cf10 0\cf4 ;\
    
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) 
\f1\b \cf7 if
\f0\b0 \cf4  (bm.\cf14 alwaysOnTime\cf4 [j]) mustOnTime++;\
    
\f1\b \cf7 if
\f0\b0 \cf4  (U_min > n - mustOnTime) \{\
        out.\cf14 feasible\cf4  = 
\f1\b \cf7 false
\f0\b0 \cf4 ;\
        out.\cf14 status\cf4  = \cf6 "PreInfeasible(U_min too large)"\cf4 ;\
        out.\cf14 time\cf4  = \cf14 nowSec\cf4 () - t0;\
        
\f1\b \cf7 return
\f0\b0 \cf4  out;\
    \}\
\
    
\f1\b \cf7 try
\f0\b0 \cf4  \{\
        \cf13 IloEnv\cf4  env;\
        \cf13 IloModel\cf4  model(env);\
\
        \cf13 IloArray\cf4 <\cf13 IloBoolVarArray\cf4 > x(env, n);\
        
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) x[j] = \cf13 IloBoolVarArray\cf4 (env, n);\
\
        \cf13 IloNumVarArray\cf4  S(env, n, \cf10 0.0\cf4 , \cf5 IloInfinity\cf4 );\
        \cf13 IloNumVarArray\cf4  C(env, n, \cf10 0.0\cf4 , \cf5 IloInfinity\cf4 );\
        \cf13 IloNumVarArray\cf4  T(env, n, \cf10 0.0\cf4 , \cf5 IloInfinity\cf4 );\
        \cf13 IloBoolVarArray\cf4  z(env, n);\
        \cf13 IloNumVar\cf4  eta(env, \cf10 0.0\cf4 , \cf5 IloInfinity\cf4 );\
\
        model.\cf14 add\cf4 (\cf14 IloMinimize\cf4 (env, eta));\
\
        \cf14 addAssignmentAndCumulativeS\cf4 (env, model, jobs, x, S);\
        \cf14 linkCompletionTimes\cf4 (env, model, jobs, x, S, C, bm.\cf14 M\cf4 );\
        \cf14 addTardinessLogic\cf4 (env, model, jobs, bm, C, T, z);\
\
        \{\
            \cf13 IloExpr\cf4  sumz(env);\
            
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) sumz += z[j];\
            model.\cf14 add\cf4 (sumz == U_min);\
            sumz.\cf14 end\cf4 ();\
        \}\
\
        \cf14 addEtaConstraints\cf4 (env, model, jobs, T, eta);\
\
        
\f1\b \cf7 if
\f0\b0 \cf4  (UB_eta < \cf10 1e100\cf4 ) model.\cf14 add\cf4 (eta <= UB_eta + \cf10 1e-6\cf4 );\
\
        
\f1\b \cf7 if
\f0\b0 \cf4  (useVI) \{\
            \cf13 VIFlags\cf4  f;\
            \cf14 addVI_MIP_P\cf4 (env, model, jobs, x, S, z, f);\
        \}\
\
        \cf13 IloCplex\cf4  cplex(model);\
        cplex.\cf14 setParam\cf4 (\cf13 IloCplex\cf4 ::\cf13 Param\cf4 ::\cf14 TimeLimit\cf4 , timeLimit);\
        cplex.\cf14 setParam\cf4 (\cf13 IloCplex\cf4 ::\cf13 Param\cf4 ::\cf14 Threads\cf4 , \cf10 1\cf4 );\
      \cf2 //  cplex.setParam(IloCplex::Param::MIP::Display, 0);\cf4 \
      \cf2 //  cplex.setOut(env.getNullStream());\cf4 \
\
        
\f1\b \cf7 bool
\f0\b0 \cf4  ok = cplex.\cf14 solve\cf4 ();\
        out.\cf14 time\cf4  = \cf14 nowSec\cf4 () - t0;\
        out.\cf14 status\cf4  = ok ? \cf14 statusToString\cf4 (cplex) : \cf6 "NoSolve"\cf4 ;\
        out.\cf14 gap\cf4  = ok ? \cf14 safeGap\cf4 (cplex) : \cf10 0.0\cf4 ;\
\
        
\f1\b \cf7 if
\f0\b0 \cf4  (ok && (cplex.\cf14 getStatus\cf4 () == \cf13 IloAlgorithm\cf4 ::\cf14 Optimal\cf4  || cplex.\cf14 getStatus\cf4 () == \cf13 IloAlgorithm\cf4 ::\cf14 Feasible\cf4 )) \{\
            out.\cf14 feasible\cf4  = 
\f1\b \cf7 true
\f0\b0 \cf4 ;\
            out.\cf14 obj\cf4  = cplex.\cf14 getValue\cf4 (eta);\
\
            out.\cf14 seq\cf4 .\cf12 assign\cf4 (n, -\cf10 1\cf4 );\
            \cf14 extractSeqFromX\cf4 (cplex, x, out.\cf14 seq\cf4 );\
\
            out.\cf14 z\cf4 .\cf12 assign\cf4 (n, \cf10 0\cf4 );\
            
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) out.\cf14 z\cf4 [j] = (cplex.\cf14 getValue\cf4 (z[j]) > \cf10 0.5\cf4  ? \cf10 1\cf4  : \cf10 0\cf4 );\
\
            \cf13 SolveInfo\cf4  ev = \cf14 evalSequence\cf4 (jobs, out.\cf14 seq\cf4 );\
            out.\cf14 wTA\cf4  = ev.\cf14 wTA\cf4 ; out.\cf14 wTB\cf4  = ev.\cf14 wTB\cf4 ;\
            out.\cf14 obj\cf4  = ev.\cf14 obj\cf4 ;\
        \}\
\
        env.\cf14 end\cf4 ();\
    \} 
\f1\b \cf7 catch
\f0\b0 \cf4  (\cf13 IloException\cf4 & e) \{\
        out.\cf14 time\cf4  = \cf14 nowSec\cf4 () - t0;\
        out.\cf14 status\cf4  = \cf6 "Exception"\cf4 ;\
        out.\cf14 feasible\cf4  = 
\f1\b \cf7 false
\f0\b0 \cf4 ;\
        \cf12 cerr\cf4  << \cf6 "MIP-P exception: "\cf4  << e << \cf6 "\\n"\cf4 ;\
    \}\
    
\f1\b \cf7 return
\f0\b0 \cf4  out;\
\}\
\
\cf2 // ============================ Fixed-z subproblem (exact sequencing with z fixed) ============================\cf4 \

\f1\b \cf7 static
\f0\b0 \cf4  \cf13 SolveInfo\cf4  \cf11 solveSubproblem_MIP_P_fixedZ\cf4 (
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 vector\cf4 <\cf13 Job\cf4 >& jobs, 
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 >& b,\
                                             
\f1\b \cf7 double
\f0\b0 \cf4  UB_eta, 
\f1\b \cf7 double
\f0\b0 \cf4  timeLimit,\
                                             
\f1\b \cf7 bool
\f0\b0 \cf4  useVI12)\
\{\
    \cf13 SolveInfo\cf4  out;\
    
\f1\b \cf7 double
\f0\b0 \cf4  t0 = \cf14 nowSec\cf4 ();\
    
\f1\b \cf7 int
\f0\b0 \cf4  n = (
\f1\b \cf7 int
\f0\b0 \cf4 )jobs.\cf12 size\cf4 ();\
    \cf13 BigMData\cf4  bm = \cf14 computeBigM\cf4 (jobs);\
    
\f1\b \cf7 double
\f0\b0 \cf4  eps = \cf10 1e-6\cf4 ;\
\
    
\f1\b \cf7 try
\f0\b0 \cf4  \{\
        \cf13 IloEnv\cf4  env;\
        \cf13 IloModel\cf4  model(env);\
\
        \cf13 IloArray\cf4 <\cf13 IloBoolVarArray\cf4 > x(env, n);\
        
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) x[j] = \cf13 IloBoolVarArray\cf4 (env, n);\
\
        \cf13 IloNumVarArray\cf4  S(env, n, \cf10 0.0\cf4 , \cf5 IloInfinity\cf4 );\
        \cf13 IloNumVarArray\cf4  C(env, n, \cf10 0.0\cf4 , \cf5 IloInfinity\cf4 );\
        \cf13 IloNumVarArray\cf4  T(env, n, \cf10 0.0\cf4 , \cf5 IloInfinity\cf4 );\
        \cf13 IloNumVar\cf4  eta(env, \cf10 0.0\cf4 , \cf5 IloInfinity\cf4 );\
\
        model.\cf14 add\cf4 (\cf14 IloMinimize\cf4 (env, eta));\
\
        \cf14 addAssignmentAndCumulativeS\cf4 (env, model, jobs, x, S);\
        \cf14 linkCompletionTimes\cf4 (env, model, jobs, x, S, C, bm.\cf14 M\cf4 );\
\
        
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) \{\
            
\f1\b \cf7 if
\f0\b0 \cf4  (bm.\cf14 alwaysOnTime\cf4 [j]) \{\
                
\f1\b \cf7 if
\f0\b0 \cf4  (b[j] == \cf10 1\cf4 ) \{\
                    \cf13 IloNumVar\cf4  dummy(env, \cf10 0.0\cf4 , \cf10 1.0\cf4 );\
                    model.\cf14 add\cf4 (dummy >= \cf10 2.0\cf4 );\
                \} 
\f1\b \cf7 else
\f0\b0 \cf4  \{\
                    model.\cf14 add\cf4 (T[j] == \cf10 0\cf4 );\
                    model.\cf14 add\cf4 (C[j] <= jobs[j].\cf14 d\cf4 );\
                \}\
            \} 
\f1\b \cf7 else
\f0\b0 \cf4  \{\
                
\f1\b \cf7 if
\f0\b0 \cf4  (b[j] == \cf10 0\cf4 ) \{\
                    model.\cf14 add\cf4 (T[j] == \cf10 0\cf4 );\
                    model.\cf14 add\cf4 (C[j] <= jobs[j].\cf14 d\cf4 );\
                \} 
\f1\b \cf7 else
\f0\b0 \cf4  \{\
                    model.\cf14 add\cf4 (C[j] >= jobs[j].\cf14 d\cf4  + eps);\
                    model.\cf14 add\cf4 (T[j] >= C[j] - jobs[j].\cf14 d\cf4 );\
                    model.\cf14 add\cf4 (T[j] <= C[j] - jobs[j].\cf14 d\cf4 );\
                    model.\cf14 add\cf4 (T[j] <= bm.\cf12 Mj\cf4 [j]);\
                \}\
            \}\
        \}\
\
        \cf14 addEtaConstraints\cf4 (env, model, jobs, T, eta);\
        
\f1\b \cf7 if
\f0\b0 \cf4  (UB_eta < \cf10 1e100\cf4 ) model.\cf14 add\cf4 (eta <= UB_eta + \cf10 1e-6\cf4 );\
\
        
\f1\b \cf7 if
\f0\b0 \cf4  (useVI12) \{\
            \cf13 VIFlags\cf4  f;\
            f.\cf14 VI3_edd_prefix_cover\cf4  = 
\f1\b \cf7 false
\f0\b0 \cf4 ;\
            f.\cf14 VI4_capacity_deadlines\cf4  = 
\f1\b \cf7 false
\f0\b0 \cf4 ;\
            f.\cf14 VI5_pairwise\cf4  = 
\f1\b \cf7 false
\f0\b0 \cf4 ;\
            \cf13 IloBoolVarArray\cf4  zDummy(env, n);\
            \cf14 addVI_MIP_P\cf4 (env, model, jobs, x, S, zDummy, f);\
        \}\
\
        \cf13 IloCplex\cf4  cplex(model);\
        cplex.\cf14 setParam\cf4 (\cf13 IloCplex\cf4 ::\cf13 Param\cf4 ::\cf14 TimeLimit\cf4 , timeLimit);\
        cplex.\cf14 setParam\cf4 (\cf13 IloCplex\cf4 ::\cf13 Param\cf4 ::\cf14 Threads\cf4 , \cf10 1\cf4 );\
        cplex.\cf14 setParam\cf4 (\cf13 IloCplex\cf4 ::\cf13 Param\cf4 ::\cf13 MIP\cf4 ::\cf14 Display\cf4 , \cf10 0\cf4 );\
        cplex.\cf14 setOut\cf4 (env.\cf14 getNullStream\cf4 ());\
\
        
\f1\b \cf7 bool
\f0\b0 \cf4  ok = cplex.\cf14 solve\cf4 ();\
        out.\cf14 time\cf4  = \cf14 nowSec\cf4 () - t0;\
        out.\cf14 status\cf4  = ok ? \cf14 statusToString\cf4 (cplex) : \cf6 "NoSolve"\cf4 ;\
        out.\cf14 gap\cf4  = ok ? \cf14 safeGap\cf4 (cplex) : \cf10 0.0\cf4 ;\
\
        
\f1\b \cf7 if
\f0\b0 \cf4  (ok && (cplex.\cf14 getStatus\cf4 () == \cf13 IloAlgorithm\cf4 ::\cf14 Optimal\cf4  || cplex.\cf14 getStatus\cf4 () == \cf13 IloAlgorithm\cf4 ::\cf14 Feasible\cf4 )) \{\
            out.\cf14 feasible\cf4  = 
\f1\b \cf7 true
\f0\b0 \cf4 ;\
            out.\cf14 obj\cf4  = cplex.\cf14 getValue\cf4 (eta);\
            out.\cf14 seq\cf4 .\cf12 assign\cf4 (n, -\cf10 1\cf4 );\
            \cf14 extractSeqFromX\cf4 (cplex, x, out.\cf14 seq\cf4 );\
            out.\cf14 z\cf4  = b;\
\
            \cf13 SolveInfo\cf4  ev = \cf14 evalSequence\cf4 (jobs, out.\cf14 seq\cf4 );\
            out.\cf14 wTA\cf4  = ev.\cf14 wTA\cf4 ; out.\cf14 wTB\cf4  = ev.\cf14 wTB\cf4 ;\
            out.\cf14 obj\cf4  = ev.\cf14 obj\cf4 ;\
        \}\
\
        env.\cf14 end\cf4 ();\
    \} 
\f1\b \cf7 catch
\f0\b0 \cf4  (\cf13 IloException\cf4 & e) \{\
        out.\cf14 time\cf4  = \cf14 nowSec\cf4 () - t0;\
        out.\cf14 status\cf4  = \cf6 "Exception"\cf4 ;\
        out.\cf14 feasible\cf4  = 
\f1\b \cf7 false
\f0\b0 \cf4 ;\
        \cf12 cerr\cf4  << \cf6 "Fixed-z subproblem exception: "\cf4  << e << \cf6 "\\n"\cf4 ;\
    \}\
    
\f1\b \cf7 return
\f0\b0 \cf4  out;\
\}\
\
\cf2 // ============================ Methods 3-4: TwoStage exact enumeration ============================\cf4 \

\f1\b \cf7 static
\f0\b0 \cf4  
\f1\b \cf7 void
\f0\b0 \cf4  \cf11 addNoGoodCutsToMaster\cf4 (\cf13 IloEnv\cf4 & env, \cf13 IloModel\cf4 & master, 
\f1\b \cf7 const
\f0\b0 \cf4  \cf13 IloBoolVarArray\cf4 & z,\
                                 
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 vector\cf4 <\cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 >>& visited)\
\{\
    
\f1\b \cf7 int
\f0\b0 \cf4  n = (
\f1\b \cf7 int
\f0\b0 \cf4 )z.\cf14 getSize\cf4 ();\
    
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 auto
\f0\b0 \cf4 & pat : visited) \{\
        \cf13 IloExpr\cf4  diff(env);\
        
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) diff += (pat[j] == \cf10 1\cf4 ) ? (\cf10 1\cf4  - z[j]) : z[j];\
        master.\cf14 add\cf4 (diff >= \cf10 1\cf4 );\
        diff.\cf14 end\cf4 ();\
    \}\
\}\
\

\f1\b \cf7 static
\f0\b0 \cf4  
\f1\b \cf7 void
\f0\b0 \cf4  \cf11 addDynamicFeasCutsToMaster\cf4 (\cf13 IloEnv\cf4 & env, \cf13 IloModel\cf4 & master, 
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 vector\cf4 <\cf13 Job\cf4 >& jobs,\
                                      
\f1\b \cf7 const
\f0\b0 \cf4  \cf13 IloBoolVarArray\cf4 & z,\
                                      
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 vector\cf4 <\cf13 CutPrefix\cf4 >& cuts)\
\{\
    
\f1\b \cf7 for
\f0\b0 \cf4  (\cf8 size_t\cf4  c = \cf10 0\cf4 ; c < cuts.\cf12 size\cf4 (); c++) \{\
        
\f1\b \cf7 const
\f0\b0 \cf4  \cf13 CutPrefix\cf4 & cp = cuts[c];\
        
\f1\b \cf7 if
\f0\b0 \cf4  (cp.\cf14 type\cf4  == \cf10 1\cf4 ) \{\
            \cf13 IloExpr\cf4  e(env);\
            
\f1\b \cf7 for
\f0\b0 \cf4  (\cf8 size_t\cf4  t = \cf10 0\cf4 ; t < cp.\cf14 P\cf4 .\cf12 size\cf4 (); t++) e += z[cp.\cf14 P\cf4 [t]];\
            master.\cf14 add\cf4 (e >= \cf10 1\cf4 );\
            e.\cf14 end\cf4 ();\
        \} 
\f1\b \cf7 else
\f0\b0 \cf4  
\f1\b \cf7 if
\f0\b0 \cf4  (cp.\cf14 type\cf4  == \cf10 2\cf4 ) \{\
            \cf13 IloExpr\cf4  e(env);\
            
\f1\b \cf7 for
\f0\b0 \cf4  (\cf8 size_t\cf4  t = \cf10 0\cf4 ; t < cp.\cf14 Q\cf4 .\cf12 size\cf4 (); t++) e += z[cp.\cf14 Q\cf4 [t]];\
            master.\cf14 add\cf4 (e >= \cf10 1\cf4 );\
            e.\cf14 end\cf4 ();\
        \} 
\f1\b \cf7 else
\f0\b0 \cf4  
\f1\b \cf7 if
\f0\b0 \cf4  (cp.\cf14 type\cf4  == \cf10 3\cf4 ) \{\
            \cf13 IloExpr\cf4  e(env);\
            
\f1\b \cf7 for
\f0\b0 \cf4  (\cf8 size_t\cf4  t = \cf10 0\cf4 ; t < cp.\cf14 P\cf4 .\cf12 size\cf4 (); t++) e += z[cp.\cf14 P\cf4 [t]];\
            master.\cf14 add\cf4 (e >= cp.\cf14 mP\cf4 );\
            e.\cf14 end\cf4 ();\
        \} 
\f1\b \cf7 else
\f0\b0 \cf4  
\f1\b \cf7 if
\f0\b0 \cf4  (cp.\cf14 type\cf4  == \cf10 4\cf4 ) \{\
            \cf13 IloExpr\cf4  e(env);\
            
\f1\b \cf7 for
\f0\b0 \cf4  (\cf8 size_t\cf4  t = \cf10 0\cf4 ; t < cp.\cf14 P\cf4 .\cf12 size\cf4 (); t++) e += jobs[cp.\cf14 P\cf4 [t]].\cf14 p\cf4  * z[cp.\cf14 P\cf4 [t]];\
            master.\cf14 add\cf4 (e >= cp.\cf14 Delta\cf4 );\
            e.\cf14 end\cf4 ();\
        \}\
    \}\
\}\
\

\f1\b \cf7 static
\f0\b0 \cf4  \cf13 SolveInfo\cf4  \cf11 runTwoStageP_exact\cf4 (
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 vector\cf4 <\cf13 Job\cf4 >& jobs, 
\f1\b \cf7 int
\f0\b0 \cf4  U_min, 
\f1\b \cf7 double
\f0\b0 \cf4  UB_eta,\
                                   
\f1\b \cf7 double
\f0\b0 \cf4  timeLimitTotal, 
\f1\b \cf7 bool
\f0\b0 \cf4  useVIinMaster, 
\f1\b \cf7 bool
\f0\b0 \cf4  useVI12inSub)\
\{\
    \cf13 SolveInfo\cf4  best;\
    
\f1\b \cf7 double
\f0\b0 \cf4  tStart = \cf14 nowSec\cf4 ();\
    
\f1\b \cf7 int
\f0\b0 \cf4  n = (
\f1\b \cf7 int
\f0\b0 \cf4 )jobs.\cf12 size\cf4 ();\
\
    
\f1\b \cf7 auto
\f0\b0 \cf4  mo = \cf14 mooresAlgorithm\cf4 (jobs);\
    \cf13 SolveInfo\cf4  inc = \cf14 evalSequence\cf4 (jobs, mo.\cf12 second\cf4 );\
    best = inc;\
    best.\cf14 status\cf4  = \cf6 "Incumbent(Moore)"\cf4 ;\
\
    \cf8 vector\cf4 <\cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 >> visitedZ;\
    \cf8 vector\cf4 <\cf13 CutPrefix\cf4 > dynCuts;\
    
\f1\b \cf7 int
\f0\b0 \cf4  iters = \cf10 0\cf4 ;\
\
    
\f1\b \cf7 while
\f0\b0 \cf4  (
\f1\b \cf7 true
\f0\b0 \cf4 ) \{\
        
\f1\b \cf7 double
\f0\b0 \cf4  elapsed = \cf14 nowSec\cf4 () - tStart;\
        
\f1\b \cf7 if
\f0\b0 \cf4  (elapsed >= timeLimitTotal) \{\
            best.\cf14 time\cf4  = elapsed;\
            best.\cf14 iters\cf4  = iters;\
            best.\cf14 status\cf4  = \cf6 "TimeLimit"\cf4 ;\
            
\f1\b \cf7 return
\f0\b0 \cf4  best;\
        \}\
\
        \cf13 IloEnv\cf4  env;\
        \cf13 IloModel\cf4  master(env);\
        \cf13 IloBoolVarArray\cf4  z(env, n);\
        master.\cf14 add\cf4 (\cf14 IloMinimize\cf4 (env, \cf10 0\cf4 ));\
\
        \{\
            \cf13 IloExpr\cf4  sumz(env);\
            
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) sumz += z[j];\
            master.\cf14 add\cf4 (sumz == U_min);\
            sumz.\cf14 end\cf4 ();\
        \}\
        \
        \cf13 BigMData\cf4  bm = \cf14 computeBigM\cf4 (jobs);\
        
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) 
\f1\b \cf7 if
\f0\b0 \cf4  (bm.\cf14 alwaysOnTime\cf4 [j]) master.\cf14 add\cf4 (z[j] == \cf10 0\cf4 );\
\
        
\f1\b \cf7 if
\f0\b0 \cf4  (useVIinMaster) \{\
            \cf13 VIFlags\cf4  vf;\
            vf.\cf14 VI1_prefix_S_lb\cf4  = 
\f1\b \cf7 false
\f0\b0 \cf4 ;\
            vf.\cf14 VI2_sym_identical\cf4  = 
\f1\b \cf7 false
\f0\b0 \cf4 ;\
            \cf14 addVI_Zonly\cf4 (env, master, jobs, z, vf);\
        \}\
\
        \cf14 addDynamicFeasCutsToMaster\cf4 (env, master, jobs, z, dynCuts);\
\
        
\f1\b \cf7 if
\f0\b0 \cf4  (!visitedZ.\cf12 empty\cf4 ()) \cf14 addNoGoodCutsToMaster\cf4 (env, master, z, visitedZ);\
\
        \cf13 IloCplex\cf4  cplex(master);\
        cplex.\cf14 setParam\cf4 (\cf13 IloCplex\cf4 ::\cf13 Param\cf4 ::\cf14 Threads\cf4 , \cf10 1\cf4 );\
        cplex.\cf14 setParam\cf4 (\cf13 IloCplex\cf4 ::\cf13 Param\cf4 ::\cf13 MIP\cf4 ::\cf14 Display\cf4 , \cf10 0\cf4 );\
        cplex.\cf14 setOut\cf4 (env.\cf14 getNullStream\cf4 ());\
\
        
\f1\b \cf7 double
\f0\b0 \cf4  remain = \cf12 max\cf4 (\cf10 1.0\cf4 , timeLimitTotal - elapsed);\
        cplex.\cf14 setParam\cf4 (\cf13 IloCplex\cf4 ::\cf13 Param\cf4 ::\cf14 TimeLimit\cf4 , remain);\
\
        
\f1\b \cf7 bool
\f0\b0 \cf4  ok = cplex.\cf14 solve\cf4 ();\
        iters++;\
\
        
\f1\b \cf7 if
\f0\b0 \cf4  (!ok || !(cplex.\cf14 getStatus\cf4 () == \cf13 IloAlgorithm\cf4 ::\cf14 Optimal\cf4  || cplex.\cf14 getStatus\cf4 () == \cf13 IloAlgorithm\cf4 ::\cf14 Feasible\cf4 )) \{\
            best.\cf14 time\cf4  = \cf14 nowSec\cf4 () - tStart;\
            best.\cf14 iters\cf4  = iters;\
            best.\cf14 cuts\cf4  = (
\f1\b \cf7 int
\f0\b0 \cf4 )dynCuts.\cf12 size\cf4 () + (
\f1\b \cf7 int
\f0\b0 \cf4 )visitedZ.\cf12 size\cf4 ();\
            best.\cf14 status\cf4  = \cf6 "MasterExhausted(NoSolve)"\cf4 ;\
            env.\cf14 end\cf4 ();\
            
\f1\b \cf7 return
\f0\b0 \cf4  best;\
        \}\
\
        \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > b(n, \cf10 0\cf4 );\
        
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) b[j] = (cplex.\cf14 getValue\cf4 (z[j]) > \cf10 0.5\cf4  ? \cf10 1\cf4  : \cf10 0\cf4 );\
        visitedZ.\cf12 push_back\cf4 (b);\
        env.\cf14 end\cf4 ();\
\
        
\f1\b \cf7 double
\f0\b0 \cf4  elapsed2 = \cf14 nowSec\cf4 () - tStart;\
        
\f1\b \cf7 double
\f0\b0 \cf4  remain2 = \cf12 max\cf4 (\cf10 1.0\cf4 , timeLimitTotal - elapsed2);\
        \cf13 SolveInfo\cf4  sub = \cf14 solveSubproblem_MIP_P_fixedZ\cf4 (jobs, b, best.\cf14 obj\cf4 , remain2, useVI12inSub);\
        \
        
\f1\b \cf7 if
\f0\b0 \cf4  (best.\cf14 obj\cf4 ==\cf10 0\cf4 ) \cf2 //reach the lower bound\cf4 \
            
\f1\b \cf7 break
\f0\b0 \cf4 ;\
        \
        
\f1\b \cf7 if
\f0\b0 \cf4  (sub.\cf14 feasible\cf4 ) \{\
            
\f1\b \cf7 if
\f0\b0 \cf4  (sub.\cf14 obj\cf4  < best.\cf14 obj\cf4  - \cf10 1e-9\cf4 ) \{\
                best = sub;\
                best.\cf14 status\cf4  = \cf6 "TwoStage(P) best"\cf4 ;\
            \}\
        \} 
\f1\b \cf7 else
\f0\b0 \cf4  \{\
            \cf13 CutPrefix\cf4  cp;\
            
\f1\b \cf7 if
\f0\b0 \cf4  (\cf14 findViolatedPrefixWithinOnTime\cf4 (jobs, b, cp)) \{\
                \cf13 CutPrefix\cf4  c1 = cp; c1.\cf14 type\cf4  = \cf10 1\cf4 ; dynCuts.\cf12 push_back\cf4 (c1);\
                \cf13 CutPrefix\cf4  c3 = cp; c3.\cf14 type\cf4  = \cf10 3\cf4 ; dynCuts.\cf12 push_back\cf4 (c3);\
                \cf13 CutPrefix\cf4  c4 = cp; c4.\cf14 type\cf4  = \cf10 4\cf4 ; dynCuts.\cf12 push_back\cf4 (c4);\
            \}\
        \}\
    \}\
\}\
\
\cf2 // ============================ Methods 5-6: MIP-T2 (time-indexed) ============================\cf4 \

\f1\b \cf7 static
\f0\b0 \cf4  \cf13 SolveInfo\cf4  \cf11 solveMIP_T2\cf4 (
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 vector\cf4 <\cf13 Job\cf4 >& jobs, 
\f1\b \cf7 int
\f0\b0 \cf4  U_min, 
\f1\b \cf7 double
\f0\b0 \cf4  UB_eta, 
\f1\b \cf7 double
\f0\b0 \cf4  timeLimit, 
\f1\b \cf7 bool
\f0\b0 \cf4  useVI)\
\{\
    \cf13 SolveInfo\cf4  out;\
    
\f1\b \cf7 double
\f0\b0 \cf4  t0 = \cf14 nowSec\cf4 ();\
    
\f1\b \cf7 int
\f0\b0 \cf4  n = (
\f1\b \cf7 int
\f0\b0 \cf4 )jobs.\cf12 size\cf4 ();\
    \cf13 BigMData\cf4  bm = \cf14 computeBigM\cf4 (jobs);\
    
\f1\b \cf7 int
\f0\b0 \cf4  T_hor = bm.\cf14 P\cf4 ;\
    
\f1\b \cf7 double
\f0\b0 \cf4  eps = \cf10 1e-6\cf4 ;\
\
    
\f1\b \cf7 try
\f0\b0 \cf4  \{\
        \cf13 IloEnv\cf4  env;\
        \cf13 IloModel\cf4  model(env);\
\
        \cf13 IloBoolVarArray\cf4  z(env, n);\
        \cf13 IloNumVar\cf4  eta(env, \cf10 0.0\cf4 , \cf5 IloInfinity\cf4 );\
\
        \cf8 vector\cf4 <\cf13 IloBoolVarArray\cf4 > y(n);\
        
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) \{\
            
\f1\b \cf7 int
\f0\b0 \cf4  L = T_hor - jobs[j].\cf14 p\cf4  + \cf10 1\cf4 ;\
            y[j] = \cf13 IloBoolVarArray\cf4 (env, L);\
        \}\
\
        model.\cf14 add\cf4 (\cf14 IloMinimize\cf4 (env, eta));\
\
        
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) \{\
            \cf13 IloExpr\cf4  s(env);\
            
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  t = \cf10 0\cf4 ; t < y[j].\cf14 getSize\cf4 (); t++) s += y[\cf14 j\cf4 ][t];\
            model.\cf14 add\cf4 (s == \cf10 1\cf4 );\
            s.\cf14 end\cf4 ();\
        \}\
\
        
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  tau = \cf10 1\cf4 ; tau <= T_hor; tau++) \{\
            \cf13 IloExpr\cf4  cap(env);\
            
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) \{\
                
\f1\b \cf7 int
\f0\b0 \cf4  pj = jobs[j].\cf14 p\cf4 ;\
                
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  t = \cf10 0\cf4 ; t < y[j].\cf14 getSize\cf4 (); t++) \{\
                    
\f1\b \cf7 int
\f0\b0 \cf4  start = t + \cf10 1\cf4 ;\
                    
\f1\b \cf7 int
\f0\b0 \cf4  end = t + pj;\
                    
\f1\b \cf7 if
\f0\b0 \cf4  (start <= tau && tau <= end) cap += y[\cf14 j\cf4 ][t];\
                \}\
            \}\
            model.\cf14 add\cf4 (cap <= \cf10 1\cf4 );\
            cap.\cf14 end\cf4 ();\
        \}\
\
        \cf13 IloNumVarArray\cf4  C(env, n, \cf10 0.0\cf4 , (
\f1\b \cf7 double
\f0\b0 \cf4 )T_hor);\
        
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) \{\
            \cf13 IloExpr\cf4  cj(env);\
            
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  t = \cf10 0\cf4 ; t < y[j].\cf14 getSize\cf4 (); t++) \{\
                
\f1\b \cf7 int
\f0\b0 \cf4  comp = (t + jobs[j].\cf14 p\cf4 );\
                cj += comp * y[\cf14 j\cf4 ][t];\
            \}\
            model.\cf14 add\cf4 (C[j] == cj);\
            cj.\cf14 end\cf4 ();\
        \}\
\
        \cf13 IloNumVarArray\cf4  Td(env, n, \cf10 0.0\cf4 , \cf5 IloInfinity\cf4 );\
        
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) \{\
            
\f1\b \cf7 if
\f0\b0 \cf4  (bm.\cf14 alwaysOnTime\cf4 [j]) \{\
                model.\cf14 add\cf4 (z[j] == \cf10 0\cf4 );\
                model.\cf14 add\cf4 (Td[j] == \cf10 0\cf4 );\
                model.\cf14 add\cf4 (C[j] <= jobs[j].\cf14 d\cf4 );\
            \} 
\f1\b \cf7 else
\f0\b0 \cf4  \{\
                model.\cf14 add\cf4 (Td[j] >= C[j] - jobs[j].\cf14 d\cf4 );\
                model.\cf14 add\cf4 (Td[j] >= \cf10 0\cf4 );\
                model.\cf14 add\cf4 (Td[j] <= (C[j] - jobs[j].\cf14 d\cf4 ) + bm.\cf14 M\cf4  * (\cf10 1\cf4  - z[j]));\
                model.\cf14 add\cf4 (Td[j] <= bm.\cf14 M\cf4  * z[j]);\
                model.\cf14 add\cf4 (C[j] <= jobs[j].\cf14 d\cf4  + bm.\cf14 M\cf4  * z[j]);\
                model.\cf14 add\cf4 (C[j] >= jobs[j].\cf14 d\cf4  - bm.\cf14 M\cf4  * (\cf10 1\cf4  - z[j]));\
                model.\cf14 add\cf4 (C[j] >= jobs[j].\cf14 d\cf4  + eps - bm.\cf14 M\cf4  * (\cf10 1\cf4  - z[j]));\
            \}\
        \}\
\
        \cf14 addEtaConstraints\cf4 (env, model, jobs, Td, eta);\
\
        \{\
            \cf13 IloExpr\cf4  sumz(env);\
            
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) sumz += z[j];\
            model.\cf14 add\cf4 (sumz == U_min);\
            sumz.\cf14 end\cf4 ();\
        \}\
        
\f1\b \cf7 if
\f0\b0 \cf4  (UB_eta < \cf10 1e100\cf4 ) model.\cf14 add\cf4 (eta <= UB_eta + \cf10 1e-6\cf4 );\
\
        
\f1\b \cf7 if
\f0\b0 \cf4  (useVI) \{\
            \cf13 VIFlags\cf4  vf;\
            vf.\cf14 VI1_prefix_S_lb\cf4  = 
\f1\b \cf7 false
\f0\b0 \cf4 ;\
            vf.\cf14 VI2_sym_identical\cf4  = 
\f1\b \cf7 false
\f0\b0 \cf4 ;\
            \cf14 addVI_Zonly\cf4 (env, model, jobs, z, vf);\
\
            
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) \{\
                
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  t = \cf10 0\cf4 ; t < y[j].\cf14 getSize\cf4 (); t++) \{\
                    
\f1\b \cf7 int
\f0\b0 \cf4  comp = (t + jobs[j].\cf14 p\cf4 );\
                    
\f1\b \cf7 if
\f0\b0 \cf4  (comp <= jobs[j].\cf14 d\cf4 ) \{\
                        model.\cf14 add\cf4 (y[\cf14 j\cf4 ][t] <= \cf10 1\cf4  - z[j]);\
                    \}\
                    
\f1\b \cf7 if
\f0\b0 \cf4  (comp >= jobs[j].\cf14 d\cf4  + eps) \{\
                        model.\cf14 add\cf4 (y[\cf14 j\cf4 ][t] <= z[j]);\
                    \}\
                \}\
            \}\
        \}\
\
        \cf13 IloCplex\cf4  cplex(model);\
        cplex.\cf14 setParam\cf4 (\cf13 IloCplex\cf4 ::\cf13 Param\cf4 ::\cf14 TimeLimit\cf4 , timeLimit);\
        cplex.\cf14 setParam\cf4 (\cf13 IloCplex\cf4 ::\cf13 Param\cf4 ::\cf14 Threads\cf4 , \cf10 1\cf4 );\
        cplex.\cf14 setParam\cf4 (\cf13 IloCplex\cf4 ::\cf13 Param\cf4 ::\cf13 MIP\cf4 ::\cf14 Display\cf4 , \cf10 0\cf4 );\
        cplex.\cf14 setOut\cf4 (env.\cf14 getNullStream\cf4 ());\
\
        
\f1\b \cf7 bool
\f0\b0 \cf4  ok = cplex.\cf14 solve\cf4 ();\
        out.\cf14 time\cf4  = \cf14 nowSec\cf4 () - t0;\
        out.\cf14 status\cf4  = ok ? \cf14 statusToString\cf4 (cplex) : \cf6 "NoSolve"\cf4 ;\
        out.\cf14 gap\cf4  = ok ? \cf14 safeGap\cf4 (cplex) : \cf10 0.0\cf4 ;\
\
        
\f1\b \cf7 if
\f0\b0 \cf4  (ok && (cplex.\cf14 getStatus\cf4 () == \cf13 IloAlgorithm\cf4 ::\cf14 Optimal\cf4  || cplex.\cf14 getStatus\cf4 () == \cf13 IloAlgorithm\cf4 ::\cf14 Feasible\cf4 )) \{\
            out.\cf14 feasible\cf4  = 
\f1\b \cf7 true
\f0\b0 \cf4 ;\
            out.\cf14 obj\cf4  = cplex.\cf14 getValue\cf4 (eta);\
            out.\cf14 z\cf4 .\cf12 assign\cf4 (n, \cf10 0\cf4 );\
            
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) out.\cf14 z\cf4 [j] = (cplex.\cf14 getValue\cf4 (z[j]) > \cf10 0.5\cf4  ? \cf10 1\cf4  : \cf10 0\cf4 );\
        \}\
\
        env.\cf14 end\cf4 ();\
    \} 
\f1\b \cf7 catch
\f0\b0 \cf4  (\cf13 IloException\cf4 & e) \{\
        out.\cf14 time\cf4  = \cf14 nowSec\cf4 () - t0;\
        out.\cf14 status\cf4  = \cf6 "Exception"\cf4 ;\
        out.\cf14 feasible\cf4  = 
\f1\b \cf7 false
\f0\b0 \cf4 ;\
        \cf12 cerr\cf4  << \cf6 "MIP-T2 exception: "\cf4  << e << \cf6 "\\n"\cf4 ;\
    \}\
    
\f1\b \cf7 return
\f0\b0 \cf4  out;\
\}\
\
\cf2 // ============================ Heuristic AB Improved (Method 7) ============================\cf4 \
\cf2 // Helper functions for Heuristic AB\cf4 \

\f1\b \cf7 static
\f0\b0 \cf4  
\f1\b \cf7 inline
\f0\b0 \cf4  \cf8 string\cf4  \cf11 packBitsKey\cf4 (
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 >& z01) \{\
    
\f1\b \cf7 const
\f0\b0 \cf4  
\f1\b \cf7 int
\f0\b0 \cf4  n = (
\f1\b \cf7 int
\f0\b0 \cf4 )z01.\cf12 size\cf4 ();\
    
\f1\b \cf7 const
\f0\b0 \cf4  
\f1\b \cf7 int
\f0\b0 \cf4  nBytes = (n + \cf10 7\cf4 ) / \cf10 8\cf4 ;\
    \cf8 string\cf4  key(nBytes, \cf10 '\\0'\cf4 );\
    
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  i = \cf10 0\cf4 ; i < n; ++i) \{\
        
\f1\b \cf7 if
\f0\b0 \cf4  (z01[i]) key[i >> \cf10 3\cf4 ] = (
\f1\b \cf7 char
\f0\b0 \cf4 )( key[i >> \cf10 3\cf4 ] | (
\f1\b \cf7 char
\f0\b0 \cf4 )(\cf10 1u\cf4  << (i & \cf10 7\cf4 )) );\
    \}\
    
\f1\b \cf7 return
\f0\b0 \cf4  key;\
\}\
\

\f1\b \cf7 static
\f0\b0 \cf4  
\f1\b \cf7 inline
\f0\b0 \cf4  \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > \cf11 unpackBitsKey\cf4 (
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 string\cf4 & key, 
\f1\b \cf7 int
\f0\b0 \cf4  n) \{\
    \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > z(n, \cf10 0\cf4 );\
    
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  i = \cf10 0\cf4 ; i < n; ++i) \{\
        
\f1\b \cf7 unsigned
\f0\b0 \cf4  
\f1\b \cf7 char
\f0\b0 \cf4  byte = (
\f1\b \cf7 unsigned
\f0\b0 \cf4  
\f1\b \cf7 char
\f0\b0 \cf4 )key[i >> \cf10 3\cf4 ];\
        z[i] = ((byte >> (i & \cf10 7\cf4 )) & \cf10 1u\cf4 ) ? \cf10 1\cf4  : \cf10 0\cf4 ;\
    \}\
    
\f1\b \cf7 return
\f0\b0 \cf4  z;\
\}\
\

\f1\b \cf7 static
\f0\b0 \cf4  
\f1\b \cf7 inline
\f0\b0 \cf4  \cf13 IloExpr\cf4  \cf11 buildHamExpr\cf4 (\cf13 IloEnv\cf4  env, 
\f1\b \cf7 const
\f0\b0 \cf4  \cf13 IloBoolVarArray\cf4 & z, 
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 >& b) \{\
    
\f1\b \cf7 const
\f0\b0 \cf4  
\f1\b \cf7 int
\f0\b0 \cf4  n = (
\f1\b \cf7 int
\f0\b0 \cf4 )b.\cf12 size\cf4 ();\
    \cf13 IloExpr\cf4  ham(env);\
    
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; ++j) ham += (b[j] == \cf10 1\cf4 ) ? (\cf10 1\cf4  - z[j]) : z[j];\
    
\f1\b \cf7 return
\f0\b0 \cf4  ham;\
\}\
\
\cf2 // Robust constructor (on-time EDD, tardy EDD, then push any accidental on-time tardy to the right)\cf4 \

\f1\b \cf7 static
\f0\b0 \cf4  
\f1\b \cf7 bool
\f0\b0 \cf4  \cf11 buildSeq_BlockRepair\cf4 (
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 vector\cf4 <\cf13 Job\cf4 >& jobs, 
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 >& b, \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 >& seqOut) \{\
    
\f1\b \cf7 int
\f0\b0 \cf4  n = (
\f1\b \cf7 int
\f0\b0 \cf4 )jobs.\cf12 size\cf4 ();\
    \cf13 BigMData\cf4  bm = \cf14 computeBigM\cf4 (jobs);\
\
    \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > S0, S1;\
    S0.\cf12 reserve\cf4 (n); S1.\cf12 reserve\cf4 (n);\
    
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; ++j) \{\
        
\f1\b \cf7 if
\f0\b0 \cf4  (b[j] == \cf10 0\cf4 ) S0.\cf12 push_back\cf4 (j);\
        
\f1\b \cf7 else
\f0\b0 \cf4  \{\
            
\f1\b \cf7 if
\f0\b0 \cf4  (bm.\cf14 alwaysOnTime\cf4 [j]) 
\f1\b \cf7 return
\f0\b0 \cf4  
\f1\b \cf7 false
\f0\b0 \cf4 ;\
            S1.\cf12 push_back\cf4 (j);\
        \}\
    \}\
\
    \cf12 sort\cf4 (S0.\cf12 begin\cf4 (), S0.\cf12 end\cf4 (), [&](
\f1\b \cf7 int
\f0\b0 \cf4  a, 
\f1\b \cf7 int
\f0\b0 \cf4  c)\{ 
\f1\b \cf7 return
\f0\b0 \cf4  jobs[a].\cf14 d\cf4  < jobs[c].\cf14 d\cf4 ; \});\
    \cf12 sort\cf4 (S1.\cf12 begin\cf4 (), S1.\cf12 end\cf4 (), [&](
\f1\b \cf7 int
\f0\b0 \cf4  a, 
\f1\b \cf7 int
\f0\b0 \cf4  c)\{ 
\f1\b \cf7 return
\f0\b0 \cf4  jobs[a].\cf14 d\cf4  < jobs[c].\cf14 d\cf4 ; \});\
\
    seqOut.\cf12 clear\cf4 ();\
    seqOut.\cf12 insert\cf4 (seqOut.\cf12 end\cf4 (), S0.\cf12 begin\cf4 (), S0.\cf12 end\cf4 ());\
    
\f1\b \cf7 int
\f0\b0 \cf4  startTardy = (
\f1\b \cf7 int
\f0\b0 \cf4 )seqOut.\cf12 size\cf4 ();\
    seqOut.\cf12 insert\cf4 (seqOut.\cf12 end\cf4 (), S1.\cf12 begin\cf4 (), S1.\cf12 end\cf4 ());\
\
    \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > C(n,\cf10 0\cf4 );\
    
\f1\b \cf7 auto
\f0\b0 \cf4  recompute = [&]()\{\
        
\f1\b \cf7 int
\f0\b0 \cf4  t=\cf10 0\cf4 ;\
        
\f1\b \cf7 for
\f0\b0 \cf4 (
\f1\b \cf7 int
\f0\b0 \cf4  k=\cf10 0\cf4 ;k<n;k++)\{ 
\f1\b \cf7 int
\f0\b0 \cf4  j=seqOut[k]; t+=jobs[j].\cf14 p\cf4 ; C[j]=t; \}\
    \};\
    recompute();\
\
    
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  k = \cf10 0\cf4 ; k < startTardy; ++k) \{\
        
\f1\b \cf7 int
\f0\b0 \cf4  j = seqOut[k];\
        
\f1\b \cf7 if
\f0\b0 \cf4  (C[j] > jobs[j].\cf14 d\cf4 ) 
\f1\b \cf7 return
\f0\b0 \cf4  
\f1\b \cf7 false
\f0\b0 \cf4 ;\
    \}\
\
    
\f1\b \cf7 bool
\f0\b0 \cf4  changed = 
\f1\b \cf7 true
\f0\b0 \cf4 ;\
    
\f1\b \cf7 int
\f0\b0 \cf4  safety = \cf10 0\cf4 ;\
    
\f1\b \cf7 while
\f0\b0 \cf4  (changed && safety++ < n*n) \{\
        changed = 
\f1\b \cf7 false
\f0\b0 \cf4 ;\
        recompute();\
        
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  k = startTardy; k < n; ++k) \{\
            
\f1\b \cf7 int
\f0\b0 \cf4  j = seqOut[k];\
            
\f1\b \cf7 if
\f0\b0 \cf4  (b[j] == \cf10 1\cf4  && C[j] <= jobs[j].\cf14 d\cf4 ) \{\
                
\f1\b \cf7 if
\f0\b0 \cf4  (k == n - \cf10 1\cf4 ) 
\f1\b \cf7 return
\f0\b0 \cf4  
\f1\b \cf7 false
\f0\b0 \cf4 ;\
                \cf12 swap\cf4 (seqOut[k], seqOut[k+\cf10 1\cf4 ]);\
                changed = 
\f1\b \cf7 true
\f0\b0 \cf4 ;\
                
\f1\b \cf7 break
\f0\b0 \cf4 ;\
            \}\
        \}\
    \}\
\
    
\f1\b \cf7 int
\f0\b0 \cf4  t=\cf10 0\cf4 ;\
    
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  k=\cf10 0\cf4 ;k<n;k++)\{\
        
\f1\b \cf7 int
\f0\b0 \cf4  j=seqOut[k];\
        t += jobs[j].\cf14 p\cf4 ;\
        
\f1\b \cf7 if
\f0\b0 \cf4  (b[j]==\cf10 0\cf4  && t>jobs[j].\cf14 d\cf4 ) 
\f1\b \cf7 return
\f0\b0 \cf4  
\f1\b \cf7 false
\f0\b0 \cf4 ;\
        
\f1\b \cf7 if
\f0\b0 \cf4  (b[j]==\cf10 1\cf4  && t<=jobs[j].\cf14 d\cf4 ) 
\f1\b \cf7 return
\f0\b0 \cf4  
\f1\b \cf7 false
\f0\b0 \cf4 ;\
    \}\
    
\f1\b \cf7 return
\f0\b0 \cf4  
\f1\b \cf7 true
\f0\b0 \cf4 ;\
\}\
\
\cf2 // Improved tardy-order constructor for heuristic: signed-greedy for tardy block\cf4 \

\f1\b \cf7 static
\f0\b0 \cf4  
\f1\b \cf7 bool
\f0\b0 \cf4  \cf11 buildSeq_HeurSignedTardy\cf4 (
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 vector\cf4 <\cf13 Job\cf4 >& jobs, 
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 >& b, \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 >& seqOut) \{\
    
\f1\b \cf7 int
\f0\b0 \cf4  n = (
\f1\b \cf7 int
\f0\b0 \cf4 )jobs.\cf12 size\cf4 ();\
    \cf13 BigMData\cf4  bm = \cf14 computeBigM\cf4 (jobs);\
\
    
\f1\b \cf7 int
\f0\b0 \cf4  nA=\cf10 0\cf4 ,nB=\cf10 0\cf4 ;\
    
\f1\b \cf7 for
\f0\b0 \cf4 (
\f1\b \cf7 int
\f0\b0 \cf4  j=\cf10 0\cf4 ;j<n;j++) (jobs[j].\cf14 agent\cf4 ==\cf10 0\cf4 ? nA:nB)++;\
\
    
\f1\b \cf7 auto
\f0\b0 \cf4  coeff = [&](
\f1\b \cf7 int
\f0\b0 \cf4  j)->
\f1\b \cf7 double
\f0\b0 \cf4 \{\
        
\f1\b \cf7 if
\f0\b0 \cf4  (jobs[j].\cf14 agent\cf4 ==\cf10 0\cf4 ) 
\f1\b \cf7 return
\f0\b0 \cf4  (
\f1\b \cf7 double
\f0\b0 \cf4 )jobs[j].\cf14 w\cf4 /(
\f1\b \cf7 double
\f0\b0 \cf4 )nA;\
        
\f1\b \cf7 return
\f0\b0 \cf4  -(
\f1\b \cf7 double
\f0\b0 \cf4 )jobs[j].\cf14 w\cf4 /(
\f1\b \cf7 double
\f0\b0 \cf4 )nB;\
    \};\
\
    \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > onTime, tardy;\
    onTime.\cf12 reserve\cf4 (n); tardy.\cf12 reserve\cf4 (n);\
    
\f1\b \cf7 for
\f0\b0 \cf4 (
\f1\b \cf7 int
\f0\b0 \cf4  j=\cf10 0\cf4 ;j<n;j++)\{\
        
\f1\b \cf7 if
\f0\b0 \cf4 (b[j]==\cf10 0\cf4 ) onTime.\cf12 push_back\cf4 (j);\
        
\f1\b \cf7 else
\f0\b0 \cf4  \{\
            
\f1\b \cf7 if
\f0\b0 \cf4  (bm.\cf14 alwaysOnTime\cf4 [j]) 
\f1\b \cf7 return
\f0\b0 \cf4  
\f1\b \cf7 false
\f0\b0 \cf4 ;\
            tardy.\cf12 push_back\cf4 (j);\
        \}\
    \}\
\
    \cf12 sort\cf4 (onTime.\cf12 begin\cf4 (), onTime.\cf12 end\cf4 (), [&](
\f1\b \cf7 int
\f0\b0 \cf4  a,
\f1\b \cf7 int
\f0\b0 \cf4  c)\{ 
\f1\b \cf7 return
\f0\b0 \cf4  jobs[a].\cf14 d\cf4  < jobs[c].\cf14 d\cf4 ; \});\
\
    
\f1\b \cf7 int
\f0\b0 \cf4  t=\cf10 0\cf4 ;\
    
\f1\b \cf7 for
\f0\b0 \cf4 (
\f1\b \cf7 int
\f0\b0 \cf4  j: onTime)\{\
        t += jobs[j].\cf14 p\cf4 ;\
        
\f1\b \cf7 if
\f0\b0 \cf4  (t > jobs[j].\cf14 d\cf4 ) 
\f1\b \cf7 return
\f0\b0 \cf4  
\f1\b \cf7 false
\f0\b0 \cf4 ;\
    \}\
    
\f1\b \cf7 int
\f0\b0 \cf4  t0 = t;\
\
    \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > rem = tardy;\
    \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > order;\
    order.\cf12 reserve\cf4 (rem.\cf12 size\cf4 ());\
\
    
\f1\b \cf7 double
\f0\b0 \cf4  diff = \cf10 0.0\cf4 ;\
    
\f1\b \cf7 int
\f0\b0 \cf4  curT = t0;\
\
    
\f1\b \cf7 int
\f0\b0 \cf4  guard = \cf10 0\cf4 ;\
    
\f1\b \cf7 while
\f0\b0 \cf4 (!rem.\cf12 empty\cf4 () && guard++ < n*n)\{\
        
\f1\b \cf7 int
\f0\b0 \cf4  bestIdx = -\cf10 1\cf4 ;\
        
\f1\b \cf7 double
\f0\b0 \cf4  bestScore = \cf10 1e100\cf4 ;\
\
        
\f1\b \cf7 for
\f0\b0 \cf4 (
\f1\b \cf7 int
\f0\b0 \cf4  i=\cf10 0\cf4 ;i<(
\f1\b \cf7 int
\f0\b0 \cf4 )rem.\cf12 size\cf4 ();i++)\{\
            
\f1\b \cf7 int
\f0\b0 \cf4  j = rem[i];\
            
\f1\b \cf7 int
\f0\b0 \cf4  Cj = curT + jobs[j].\cf14 p\cf4 ;\
            
\f1\b \cf7 if
\f0\b0 \cf4  (Cj <= jobs[j].\cf14 d\cf4 ) 
\f1\b \cf7 continue
\f0\b0 \cf4 ;\
            
\f1\b \cf7 double
\f0\b0 \cf4  contrib = coeff(j) * ((
\f1\b \cf7 double
\f0\b0 \cf4 )Cj - (
\f1\b \cf7 double
\f0\b0 \cf4 )jobs[j].\cf14 d\cf4 );\
            
\f1\b \cf7 double
\f0\b0 \cf4  score = \cf12 fabs\cf4 ((diff + contrib));\
            score += \cf10 1e-9\cf4  * (-\cf12 fabs\cf4 (coeff(j)) * (
\f1\b \cf7 double
\f0\b0 \cf4 )jobs[j].\cf14 p\cf4 );\
            
\f1\b \cf7 if
\f0\b0 \cf4  (score < bestScore)\{\
                bestScore = score;\
                bestIdx = i;\
            \}\
        \}\
\
        
\f1\b \cf7 if
\f0\b0 \cf4  (bestIdx == -\cf10 1\cf4 ) \{\
            
\f1\b \cf7 return
\f0\b0 \cf4  \cf14 buildSeq_BlockRepair\cf4 (jobs, b, seqOut);\
        \}\
\
        
\f1\b \cf7 int
\f0\b0 \cf4  j = rem[bestIdx];\
        
\f1\b \cf7 int
\f0\b0 \cf4  Cj = curT + jobs[j].\cf14 p\cf4 ;\
        diff += coeff(j) * ((
\f1\b \cf7 double
\f0\b0 \cf4 )Cj - (
\f1\b \cf7 double
\f0\b0 \cf4 )jobs[j].\cf14 d\cf4 );\
        curT = Cj;\
        order.\cf12 push_back\cf4 (j);\
        rem.\cf12 erase\cf4 (rem.\cf12 begin\cf4 () + bestIdx);\
    \}\
\
    seqOut.\cf12 clear\cf4 ();\
    seqOut.\cf12 insert\cf4 (seqOut.\cf12 end\cf4 (), onTime.\cf12 begin\cf4 (), onTime.\cf12 end\cf4 ());\
    seqOut.\cf12 insert\cf4 (seqOut.\cf12 end\cf4 (), order.\cf12 begin\cf4 (), order.\cf12 end\cf4 ());\
\
    
\f1\b \cf7 int
\f0\b0 \cf4  tt=\cf10 0\cf4 ;\
    
\f1\b \cf7 for
\f0\b0 \cf4 (
\f1\b \cf7 int
\f0\b0 \cf4  k=\cf10 0\cf4 ;k<n;k++)\{\
        
\f1\b \cf7 int
\f0\b0 \cf4  j=seqOut[k];\
        tt += jobs[j].\cf14 p\cf4 ;\
        
\f1\b \cf7 if
\f0\b0 \cf4  (b[j]==\cf10 0\cf4  && tt>jobs[j].\cf14 d\cf4 ) 
\f1\b \cf7 return
\f0\b0 \cf4  
\f1\b \cf7 false
\f0\b0 \cf4 ;\
        
\f1\b \cf7 if
\f0\b0 \cf4  (b[j]==\cf10 1\cf4  && tt<=jobs[j].\cf14 d\cf4 ) 
\f1\b \cf7 return
\f0\b0 \cf4  
\f1\b \cf7 false
\f0\b0 \cf4 ;\
    \}\
    
\f1\b \cf7 return
\f0\b0 \cf4  
\f1\b \cf7 true
\f0\b0 \cf4 ;\
\}\
\
\cf2 // Simple local swap search in tardy block\cf4 \

\f1\b \cf7 static
\f0\b0 \cf4  
\f1\b \cf7 void
\f0\b0 \cf4  \cf11 improveSeq_TardyLocal\cf4 (
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 vector\cf4 <\cf13 Job\cf4 >& jobs, 
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 >& b, \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 >& seq, 
\f1\b \cf7 int
\f0\b0 \cf4  maxTries, \cf8 mt19937\cf4 & rng) \{\
    
\f1\b \cf7 int
\f0\b0 \cf4  n = (
\f1\b \cf7 int
\f0\b0 \cf4 )jobs.\cf12 size\cf4 ();\
    \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > pos(n,-\cf10 1\cf4 );\
    
\f1\b \cf7 for
\f0\b0 \cf4 (
\f1\b \cf7 int
\f0\b0 \cf4  k=\cf10 0\cf4 ;k<n;k++) pos[seq[\cf12 k\cf4 ]] = k;\
\
    
\f1\b \cf7 int
\f0\b0 \cf4  startTardy = n;\
    
\f1\b \cf7 for
\f0\b0 \cf4 (
\f1\b \cf7 int
\f0\b0 \cf4  k=\cf10 0\cf4 ;k<n;k++)\{\
        
\f1\b \cf7 if
\f0\b0 \cf4  (b[seq[\cf12 k\cf4 ]]==\cf10 1\cf4 )\{ startTardy = k; 
\f1\b \cf7 break
\f0\b0 \cf4 ; \}\
    \}\
    
\f1\b \cf7 if
\f0\b0 \cf4  (startTardy >= n-\cf10 1\cf4 ) 
\f1\b \cf7 return
\f0\b0 \cf4 ;\
\
    
\f1\b \cf7 auto
\f0\b0 \cf4  feasible = [&](
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 >& s)->
\f1\b \cf7 bool
\f0\b0 \cf4 \{\
        
\f1\b \cf7 int
\f0\b0 \cf4  t=\cf10 0\cf4 ;\
        
\f1\b \cf7 for
\f0\b0 \cf4 (
\f1\b \cf7 int
\f0\b0 \cf4  k=\cf10 0\cf4 ;k<n;k++)\{\
            
\f1\b \cf7 int
\f0\b0 \cf4  j=s[k];\
            t += jobs[j].\cf14 p\cf4 ;\
            
\f1\b \cf7 if
\f0\b0 \cf4  (b[j]==\cf10 0\cf4  && t>jobs[j].\cf14 d\cf4 ) 
\f1\b \cf7 return
\f0\b0 \cf4  
\f1\b \cf7 false
\f0\b0 \cf4 ;\
            
\f1\b \cf7 if
\f0\b0 \cf4  (b[j]==\cf10 1\cf4  && t<=jobs[j].\cf14 d\cf4 ) 
\f1\b \cf7 return
\f0\b0 \cf4  
\f1\b \cf7 false
\f0\b0 \cf4 ;\
        \}\
        
\f1\b \cf7 return
\f0\b0 \cf4  
\f1\b \cf7 true
\f0\b0 \cf4 ;\
    \};\
\
    \cf13 SolveInfo\cf4  best = \cf14 evalSequence\cf4 (jobs, seq);\
    \cf8 uniform_int_distribution\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > distK(startTardy, n-\cf10 1\cf4 );\
\
    
\f1\b \cf7 for
\f0\b0 \cf4 (
\f1\b \cf7 int
\f0\b0 \cf4  it=\cf10 0\cf4 ; it<maxTries; ++it)\{\
        
\f1\b \cf7 int
\f0\b0 \cf4  i = distK(rng);\
        
\f1\b \cf7 int
\f0\b0 \cf4  j = distK(rng);\
        
\f1\b \cf7 if
\f0\b0 \cf4  (i==j) 
\f1\b \cf7 continue
\f0\b0 \cf4 ;\
        
\f1\b \cf7 if
\f0\b0 \cf4  (i>j) \cf12 swap\cf4 (i,j);\
\
        \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > cand = seq;\
        \cf12 swap\cf4 (cand[i], cand[j]);\
\
        
\f1\b \cf7 if
\f0\b0 \cf4  (!feasible(cand)) 
\f1\b \cf7 continue
\f0\b0 \cf4 ;\
\
        \cf13 SolveInfo\cf4  ev = \cf14 evalSequence\cf4 (jobs, cand);\
        
\f1\b \cf7 if
\f0\b0 \cf4  (ev.\cf14 obj\cf4  + \cf10 1e-9\cf4  < best.\cf14 obj\cf4 )\{\
            seq.\cf12 swap\cf4 (cand);\
            best = ev;\
        \}\
    \}\
\}\
\
\cf2 // Main Heuristic AB improved function\cf4 \

\f1\b \cf7 static
\f0\b0 \cf4  \cf13 SolveInfo\cf4  \cf11 runHeuristicAB_improved2\cf4 (
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 vector\cf4 <\cf13 Job\cf4 >& jobs,\
                                          
\f1\b \cf7 int
\f0\b0 \cf4  U_min,\
                                          
\f1\b \cf7 double
\f0\b0 \cf4  timeLimit,\
                                          
\f1\b \cf7 int
\f0\b0 \cf4  seed = \cf10 123\cf4 ,\
                                          
\f1\b \cf7 int
\f0\b0 \cf4  multistarts = \cf10 60\cf4 )\
\{\
    \cf13 SolveInfo\cf4  best;\
    
\f1\b \cf7 double
\f0\b0 \cf4  tStart = \cf14 nowSec\cf4 ();\
    
\f1\b \cf7 int
\f0\b0 \cf4  n = (
\f1\b \cf7 int
\f0\b0 \cf4 )jobs.\cf12 size\cf4 ();\
    \cf13 BigMData\cf4  bm = \cf14 computeBigM\cf4 (jobs);\
\
    \cf8 mt19937\cf4  rng(seed);\
    \cf8 uniform_int_distribution\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > distJob(\cf10 0\cf4 , n-\cf10 1\cf4 );\
\
    
\f1\b \cf7 auto
\f0\b0 \cf4  mo = \cf14 mooresAlgorithm\cf4 (jobs);\
    \cf13 SolveInfo\cf4  moEv = \cf14 evalSequence\cf4 (jobs, mo.\cf12 second\cf4 );\
    \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > b0 = moEv.\cf14 z\cf4 ;\
\
    
\f1\b \cf7 auto
\f0\b0 \cf4  repairB = [&](\cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 >& b)\{\
        
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j=\cf10 0\cf4 ;j<n;j++) 
\f1\b \cf7 if
\f0\b0 \cf4  (bm.\cf14 alwaysOnTime\cf4 [j]) b[j]=\cf10 0\cf4 ;\
        
\f1\b \cf7 int
\f0\b0 \cf4  sumz = \cf12 accumulate\cf4 (b.\cf12 begin\cf4 (), b.\cf12 end\cf4 (), \cf10 0\cf4 );\
        
\f1\b \cf7 if
\f0\b0 \cf4  (sumz == U_min) 
\f1\b \cf7 return
\f0\b0 \cf4 ;\
\
        \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > C(n,\cf10 0\cf4 );\
        
\f1\b \cf7 int
\f0\b0 \cf4  t=\cf10 0\cf4 ;\
        
\f1\b \cf7 for
\f0\b0 \cf4 (
\f1\b \cf7 int
\f0\b0 \cf4  k=\cf10 0\cf4 ;k<n;k++)\{ 
\f1\b \cf7 int
\f0\b0 \cf4  j=mo.\cf12 second\cf4 [k]; t+=jobs[j].\cf14 p\cf4 ; C[j]=t; \}\
\
        \cf8 vector\cf4 <\cf8 pair\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 ,
\f1\b \cf7 int
\f0\b0 \cf4 >> rank;\
        rank.\cf12 reserve\cf4 (n);\
        
\f1\b \cf7 for
\f0\b0 \cf4 (
\f1\b \cf7 int
\f0\b0 \cf4  j=\cf10 0\cf4 ;j<n;j++)\{\
            
\f1\b \cf7 if
\f0\b0 \cf4  (bm.\cf14 alwaysOnTime\cf4 [j]) 
\f1\b \cf7 continue
\f0\b0 \cf4 ;\
            rank.\cf12 push_back\cf4 (\{C[j]-jobs[j].\cf14 d\cf4 , j\});\
        \}\
        \cf12 sort\cf4 (rank.\cf12 begin\cf4 (), rank.\cf12 end\cf4 (), \cf8 greater\cf4 <\cf8 pair\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 ,
\f1\b \cf7 int
\f0\b0 \cf4 >>());\
\
        b.\cf12 assign\cf4 (n,\cf10 0\cf4 );\
        
\f1\b \cf7 int
\f0\b0 \cf4  cnt=\cf10 0\cf4 ;\
        
\f1\b \cf7 for
\f0\b0 \cf4 (
\f1\b \cf7 auto
\f0\b0 \cf4  &pr: rank)\{\
            
\f1\b \cf7 if
\f0\b0 \cf4  (cnt < U_min) \{ b[pr.\cf12 second\cf4 ]=\cf10 1\cf4 ; cnt++; \}\
        \}\
    \};\
    repairB(b0);\
\
    
\f1\b \cf7 auto
\f0\b0 \cf4  feasiblePatternQuick = [&](
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 >& b)->
\f1\b \cf7 bool
\f0\b0 \cf4 \{\
        \cf13 CutPrefix\cf4  cp;\
        
\f1\b \cf7 return
\f0\b0 \cf4  !\cf14 findViolatedPrefixWithinOnTime\cf4 (jobs, b, cp);\
    \};\
\
    
\f1\b \cf7 auto
\f0\b0 \cf4  evalPattern = [&](
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 >& b, \cf13 SolveInfo\cf4 & out)->
\f1\b \cf7 bool
\f0\b0 \cf4 \{\
        \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > seq;\
        
\f1\b \cf7 if
\f0\b0 \cf4  (!\cf14 buildSeq_HeurSignedTardy\cf4 (jobs, b, seq)) \{\
            
\f1\b \cf7 if
\f0\b0 \cf4  (!\cf14 buildSeq_BlockRepair\cf4 (jobs, b, seq)) 
\f1\b \cf7 return
\f0\b0 \cf4  
\f1\b \cf7 false
\f0\b0 \cf4 ;\
        \}\
        out = \cf14 evalSequence\cf4 (jobs, seq);\
        out.\cf14 z\cf4  = b;\
        out.\cf14 seq\cf4  = seq;\
        
\f1\b \cf7 return
\f0\b0 \cf4  
\f1\b \cf7 true
\f0\b0 \cf4 ;\
    \};\
\
    best.\cf14 feasible\cf4  = 
\f1\b \cf7 false
\f0\b0 \cf4 ;\
    best.\cf14 obj\cf4  = \cf10 1e100\cf4 ;\
    \{\
        \cf13 SolveInfo\cf4  tmp;\
        
\f1\b \cf7 if
\f0\b0 \cf4  (feasiblePatternQuick(b0) && evalPattern(b0, tmp)) \{\
            \cf14 improveSeq_TardyLocal\cf4 (jobs, b0, tmp.\cf14 seq\cf4 , \cf10 1200\cf4 , rng);\
            tmp = \cf14 evalSequence\cf4 (jobs, tmp.\cf14 seq\cf4 );\
            tmp.\cf14 z\cf4  = b0;\
            best = tmp;\
            best.\cf14 status\cf4  = \cf6 "HeurAB-Init"\cf4 ;\
        \}\
    \}\
\
    \cf8 vector\cf4 <\cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 >> starts;\
    starts.\cf12 reserve\cf4 (multistarts+\cf10 1\cf4 );\
    starts.\cf12 push_back\cf4 (b0);\
    
\f1\b \cf7 for
\f0\b0 \cf4 (
\f1\b \cf7 int
\f0\b0 \cf4  s=\cf10 0\cf4 ;s<multistarts;s++)\{\
        \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > b = b0;\
        
\f1\b \cf7 int
\f0\b0 \cf4  swaps = \cf10 1\cf4  + (s % \cf10 2\cf4 );\
        
\f1\b \cf7 for
\f0\b0 \cf4 (
\f1\b \cf7 int
\f0\b0 \cf4  r=\cf10 0\cf4 ;r<swaps;r++)\{\
            
\f1\b \cf7 int
\f0\b0 \cf4  i=-\cf10 1\cf4 ,j=-\cf10 1\cf4 ;\
            
\f1\b \cf7 for
\f0\b0 \cf4 (
\f1\b \cf7 int
\f0\b0 \cf4  tries=\cf10 0\cf4 ;tries<\cf10 60\cf4 ;tries++)\{\
                
\f1\b \cf7 int
\f0\b0 \cf4  a=distJob(rng), c=distJob(rng);\
                
\f1\b \cf7 if
\f0\b0 \cf4  (b[a]==\cf10 1\cf4  && b[c]==\cf10 0\cf4  && !bm.\cf14 alwaysOnTime\cf4 [c]) \{ i=a; j=c; 
\f1\b \cf7 break
\f0\b0 \cf4 ; \}\
                
\f1\b \cf7 if
\f0\b0 \cf4  (b[a]==\cf10 0\cf4  && b[c]==\cf10 1\cf4  && !bm.\cf14 alwaysOnTime\cf4 [a]) \{ i=c; j=a; 
\f1\b \cf7 break
\f0\b0 \cf4 ; \}\
            \}\
            
\f1\b \cf7 if
\f0\b0 \cf4  (i!=-\cf10 1\cf4  && j!=-\cf10 1\cf4 ) \{ b[i]=\cf10 0\cf4 ; b[j]=\cf10 1\cf4 ; \}\
        \}\
        repairB(b);\
        starts.\cf12 push_back\cf4 (b);\
    \}\
\
    
\f1\b \cf7 for
\f0\b0 \cf4 (
\f1\b \cf7 auto
\f0\b0 \cf4  &bStart : starts)\{\
        
\f1\b \cf7 if
\f0\b0 \cf4  (\cf14 nowSec\cf4 () - tStart >= timeLimit) 
\f1\b \cf7 break
\f0\b0 \cf4 ;\
        \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > b = bStart;\
\
        \cf13 SolveInfo\cf4  cur;\
        
\f1\b \cf7 if
\f0\b0 \cf4  (!feasiblePatternQuick(b) || !evalPattern(b, cur)) 
\f1\b \cf7 continue
\f0\b0 \cf4 ;\
\
        \cf14 improveSeq_TardyLocal\cf4 (jobs, b, cur.\cf14 seq\cf4 , \cf10 800\cf4 , rng);\
        cur = \cf14 evalSequence\cf4 (jobs, cur.\cf14 seq\cf4 );\
        cur.\cf14 z\cf4  = b;\
\
        
\f1\b \cf7 if
\f0\b0 \cf4  (!best.\cf14 feasible\cf4  || cur.\cf14 obj\cf4  < best.\cf14 obj\cf4  - \cf10 1e-9\cf4 ) \{\
            best = cur;\
            best.\cf14 status\cf4  = \cf6 "HeurAB-Best"\cf4 ;\
        \}\
        
\f1\b \cf7 if
\f0\b0 \cf4 (best.\cf14 obj\cf4 ==\cf10 0\cf4 )\
            
\f1\b \cf7 break
\f0\b0 \cf4 ; \cf2 //achive the lower bound\cf4 \
\
        
\f1\b \cf7 int
\f0\b0 \cf4  noImp = \cf10 0\cf4 ;\
        
\f1\b \cf7 while
\f0\b0 \cf4  (\cf14 nowSec\cf4 () - tStart < timeLimit && noImp < \cf10 200\cf4 ) \{\
            
\f1\b \cf7 double
\f0\b0 \cf4  bestCandObj = cur.\cf14 obj\cf4 ;\
            \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > bestCandB = b;\
            \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > bestCandSeq = cur.\cf14 seq\cf4 ;\
\
            
\f1\b \cf7 for
\f0\b0 \cf4 (
\f1\b \cf7 int
\f0\b0 \cf4  k=\cf10 0\cf4 ;k<\cf10 25\cf4 ;k++)\{\
                
\f1\b \cf7 int
\f0\b0 \cf4  i=-\cf10 1\cf4 ,j=-\cf10 1\cf4 ;\
                
\f1\b \cf7 for
\f0\b0 \cf4 (
\f1\b \cf7 int
\f0\b0 \cf4  tries=\cf10 0\cf4 ;tries<\cf10 40\cf4 ;tries++)\{\
                    
\f1\b \cf7 int
\f0\b0 \cf4  a=distJob(rng), c=distJob(rng);\
                    
\f1\b \cf7 if
\f0\b0 \cf4  (b[a]==\cf10 1\cf4  && b[c]==\cf10 0\cf4  && !bm.\cf14 alwaysOnTime\cf4 [c]) \{ i=a; j=c; 
\f1\b \cf7 break
\f0\b0 \cf4 ; \}\
                    
\f1\b \cf7 if
\f0\b0 \cf4  (b[a]==\cf10 0\cf4  && b[c]==\cf10 1\cf4  && !bm.\cf14 alwaysOnTime\cf4 [a]) \{ i=c; j=a; 
\f1\b \cf7 break
\f0\b0 \cf4 ; \}\
                \}\
                
\f1\b \cf7 if
\f0\b0 \cf4  (i==-\cf10 1\cf4  || j==-\cf10 1\cf4 ) 
\f1\b \cf7 continue
\f0\b0 \cf4 ;\
\
                \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > candB = b;\
                candB[i]=\cf10 0\cf4 ; candB[j]=\cf10 1\cf4 ;\
\
                
\f1\b \cf7 if
\f0\b0 \cf4  (!feasiblePatternQuick(candB)) 
\f1\b \cf7 continue
\f0\b0 \cf4 ;\
\
                \cf13 SolveInfo\cf4  cand;\
                
\f1\b \cf7 if
\f0\b0 \cf4  (!evalPattern(candB, cand)) 
\f1\b \cf7 continue
\f0\b0 \cf4 ;\
\
                \cf14 improveSeq_TardyLocal\cf4 (jobs, candB, cand.\cf14 seq\cf4 , \cf10 400\cf4 , rng);\
                cand = \cf14 evalSequence\cf4 (jobs, cand.\cf14 seq\cf4 );\
                cand.\cf14 z\cf4  = candB;\
\
                
\f1\b \cf7 if
\f0\b0 \cf4  (cand.\cf14 obj\cf4  + \cf10 1e-9\cf4  < bestCandObj) \{\
                    bestCandObj = cand.\cf14 obj\cf4 ;\
                    bestCandB = candB;\
                    bestCandSeq = cand.\cf14 seq\cf4 ;\
                \}\
            \}\
\
            
\f1\b \cf7 if
\f0\b0 \cf4  (bestCandObj + \cf10 1e-9\cf4  < cur.\cf14 obj\cf4 ) \{\
                b = bestCandB;\
                cur.\cf14 obj\cf4  = bestCandObj;\
                cur.\cf14 z\cf4  = b;\
                cur.\cf14 seq\cf4  = bestCandSeq;\
                noImp = \cf10 0\cf4 ;\
\
                
\f1\b \cf7 if
\f0\b0 \cf4  (cur.\cf14 obj\cf4  + \cf10 1e-9\cf4  < best.\cf14 obj\cf4 ) \{\
                    best = cur;\
                    best.\cf14 status\cf4  = \cf6 "HeurAB-Best"\cf4 ;\
                \}\
            \} 
\f1\b \cf7 else
\f0\b0 \cf4  \{\
                noImp++;\
            \}\
        \}\
    \}\
\
    best.\cf14 feasible\cf4  = 
\f1\b \cf7 true
\f0\b0 \cf4 ;\
    best.\cf14 time\cf4  = \cf14 nowSec\cf4 () - tStart;\
    
\f1\b \cf7 if
\f0\b0 \cf4  (best.\cf14 status\cf4  == \cf6 "NA"\cf4 ) best.\cf14 status\cf4  = \cf6 "HeurAB"\cf4 ;\
    
\f1\b \cf7 return
\f0\b0 \cf4  best;\
\}\
\

\f1\b \cf7 static
\f0\b0 \cf4  \cf13 SolveInfo\cf4  \cf11 runTwoStageP_exact_withHeuristicWarmStart\cf4 (
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 vector\cf4 <\cf13 Job\cf4 >& jobs, \cf13 SolveInfo\cf4  heur, 
\f1\b \cf7 int
\f0\b0 \cf4  U_min, 
\f1\b \cf7 double
\f0\b0 \cf4  UB_eta, 
\f1\b \cf7 double
\f0\b0 \cf4  timeLimitTotal, 
\f1\b \cf7 bool
\f0\b0 \cf4  useVIinMaster, 
\f1\b \cf7 bool
\f0\b0 \cf4  useVI12inSub) \{\
    \
    \
    \
    \cf13 SolveInfo\cf4  best;\
    
\f1\b \cf7 double
\f0\b0 \cf4  tStart = \cf14 nowSec\cf4 ();\
    
\f1\b \cf7 int
\f0\b0 \cf4  n = jobs.\cf12 size\cf4 ();\
\
    \cf2 // If the heuristic already yields eta = 0, return it immediately\cf4 \
    
\f1\b \cf7 if
\f0\b0 \cf4  (heur.\cf14 obj\cf4  == \cf10 0\cf4 ) \{\
        best = heur;\
        best.\cf14 status\cf4  = \cf6 "HeuristicWarmStart (Optimal)"\cf4 ;\
        best.\cf14 time\cf4  = \cf14 nowSec\cf4 () - tStart;\
        
\f1\b \cf7 return
\f0\b0 \cf4  best;\
    \}\
\
    best = heur;\
    best.\cf14 status\cf4  = \cf6 "HeuristicWarmStart"\cf4 ;\
    \
    \cf2 // Set the initial objective to the upper bound (UB_eta)\cf4 \
    
\f1\b \cf7 double
\f0\b0 \cf4  currentObjective = heur.\cf14 obj\cf4 ;\
    
\f1\b \cf7 if
\f0\b0 \cf4  (currentObjective < \cf10 0\cf4 ) currentObjective = UB_eta;\
\
    \cf8 vector\cf4 <\cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 >> visitedZ;\
    \cf8 vector\cf4 <\cf13 CutPrefix\cf4 > dynCuts;\
    
\f1\b \cf7 int
\f0\b0 \cf4  iters = \cf10 0\cf4 ;\
\
    
\f1\b \cf7 while
\f0\b0 \cf4  (
\f1\b \cf7 true
\f0\b0 \cf4 ) \{\
        
\f1\b \cf7 double
\f0\b0 \cf4  elapsed = \cf14 nowSec\cf4 () - tStart;\
        
\f1\b \cf7 if
\f0\b0 \cf4  (elapsed >= timeLimitTotal) \{\
            best.\cf14 time\cf4  = elapsed;\
            best.\cf14 iters\cf4  = iters;\
            best.\cf14 status\cf4  = \cf6 "TimeLimit"\cf4 ;\
            
\f1\b \cf7 return
\f0\b0 \cf4  best;\
        \}\
\
        \cf13 IloEnv\cf4  env;\
        \cf13 IloModel\cf4  master(env);\
        \cf13 IloBoolVarArray\cf4  z(env, n);\
        master.\cf14 add\cf4 (\cf14 IloMinimize\cf4 (env, \cf10 0\cf4 ));  \cf2 // Objective is initialized\cf4 \
\
        \cf13 IloExpr\cf4  sumz(env);\
        
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) sumz += z[j];\
        master.\cf14 add\cf4 (sumz == U_min);\
        sumz.\cf14 end\cf4 ();\
\
        \cf13 BigMData\cf4  bm = \cf14 computeBigM\cf4 (jobs);\
        
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) 
\f1\b \cf7 if
\f0\b0 \cf4  (bm.\cf14 alwaysOnTime\cf4 [j]) master.\cf14 add\cf4 (z[j] == \cf10 0\cf4 );\
\
        \cf2 // Apply heuristic as a warm start (initialize z and obj)\cf4 \
        
\f1\b \cf7 if
\f0\b0 \cf4 (iters==\cf10 0\cf4 )\
        \{\
            
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; ++j) \{\
                
\f1\b \cf7 if
\f0\b0 \cf4  (heur.\cf14 z\cf4 [j] == \cf10 1\cf4 ) \{\
                    master.\cf14 add\cf4 (z[j] == \cf10 1\cf4 ); \cf2 // Set the heuristic z values\cf4 \
                \} 
\f1\b \cf7 else
\f0\b0 \cf4  \{\
                    master.\cf14 add\cf4 (z[j] == \cf10 0\cf4 );\
                \}\
            \}\
        \}\
\
        
\f1\b \cf7 if
\f0\b0 \cf4  (useVIinMaster) \{\
                  \cf13 VIFlags\cf4  vf;\
                  \cf2 // In master, we use VI3..VI5; VI1/VI2 are position-based\cf4 \
                  vf.\cf14 VI1_prefix_S_lb\cf4  = 
\f1\b \cf7 false
\f0\b0 \cf4 ;\
                  vf.\cf14 VI2_sym_identical\cf4  = 
\f1\b \cf7 false
\f0\b0 \cf4 ;\
                  \cf14 addVI_Zonly\cf4 (env, master, jobs, z, vf);\
              \}\
\
              \cf2 // dynamic feasibility cuts (only derived from *infeasible* subproblems)\cf4 \
              \cf14 addDynamicFeasCutsToMaster\cf4 (env, master, jobs, z, dynCuts);\
\
              \cf2 // no-good cuts\cf4 \
              
\f1\b \cf7 if
\f0\b0 \cf4  (!visitedZ.\cf12 empty\cf4 ()) \cf14 addNoGoodCutsToMaster\cf4 (env, master, z, visitedZ);\
\
\
        
\f1\b \cf7 try
\f0\b0 \cf4  \{\
            \cf13 IloCplex\cf4  cplex(master);\
            cplex.\cf14 setParam\cf4 (\cf13 IloCplex\cf4 ::\cf13 Param\cf4 ::\cf14 Threads\cf4 , \cf10 1\cf4 ); \cf2 // Multi-threading for better performance\cf4 \
            cplex.\cf14 setParam\cf4 (\cf13 IloCplex\cf4 ::\cf13 Param\cf4 ::\cf13 MIP\cf4 ::\cf14 Display\cf4 , \cf10 0\cf4 );\
            cplex.\cf14 setOut\cf4 (env.\cf14 getNullStream\cf4 ());\
            
\f1\b \cf7 double
\f0\b0 \cf4  remain = \cf12 max\cf4 (\cf10 1.0\cf4 , timeLimitTotal - elapsed);\
            cplex.\cf14 setParam\cf4 (\cf13 IloCplex\cf4 ::\cf13 Param\cf4 ::\cf14 TimeLimit\cf4 , remain);\
\
            
\f1\b \cf7 bool
\f0\b0 \cf4  ok = cplex.\cf14 solve\cf4 ();\
            iters++;\
\
            
\f1\b \cf7 if
\f0\b0 \cf4  (!ok || !(cplex.\cf14 getStatus\cf4 () == \cf13 IloAlgorithm\cf4 ::\cf14 Optimal\cf4  || cplex.\cf14 getStatus\cf4 () == \cf13 IloAlgorithm\cf4 ::\cf14 Feasible\cf4 )) \{\
                best.\cf14 time\cf4  = \cf14 nowSec\cf4 () - tStart;\
                best.\cf14 iters\cf4  = iters;\
                best.\cf14 status\cf4  = \cf6 "MasterExhausted(NoSolve)"\cf4 ;\
                env.\cf14 end\cf4 ();\
                
\f1\b \cf7 return
\f0\b0 \cf4  best;\
            \}\
\
            \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > b(n, \cf10 0\cf4 );\
            
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) b[j] = (cplex.\cf14 getValue\cf4 (z[j]) > \cf10 0.5\cf4  ? \cf10 1\cf4  : \cf10 0\cf4 );\
            visitedZ.\cf12 push_back\cf4 (b);\
            env.\cf14 end\cf4 ();\
\
            
\f1\b \cf7 double
\f0\b0 \cf4  elapsed2 = \cf14 nowSec\cf4 () - tStart;\
            
\f1\b \cf7 double
\f0\b0 \cf4  remain2 = \cf12 max\cf4 (\cf10 1.0\cf4 , timeLimitTotal - elapsed2);\
            \cf13 SolveInfo\cf4  sub = \cf14 solveSubproblem_MIP_P_fixedZ\cf4 (jobs, b, best.\cf14 obj\cf4 , remain2, useVI12inSub);\
\
            
\f1\b \cf7 if
\f0\b0 \cf4  (sub.\cf14 feasible\cf4 ) \{\
                
\f1\b \cf7 if
\f0\b0 \cf4  (sub.\cf14 obj\cf4  < best.\cf14 obj\cf4  - \cf10 1e-9\cf4 ) \{\
                    best = sub;\
                    best.\cf14 status\cf4  = \cf6 "TwoStage(P) best"\cf4 ;\
                \}\
            \} 
\f1\b \cf7 else
\f0\b0 \cf4  \{\
                \cf13 CutPrefix\cf4  cp;\
                
\f1\b \cf7 if
\f0\b0 \cf4  (\cf14 findViolatedPrefixWithinOnTime\cf4 (jobs, b, cp)) \{\
                    \cf13 CutPrefix\cf4  c1 = cp; c1.\cf14 type\cf4  = \cf10 1\cf4 ; dynCuts.\cf12 push_back\cf4 (c1);\
                    \cf13 CutPrefix\cf4  c3 = cp; c3.\cf14 type\cf4  = \cf10 3\cf4 ; dynCuts.\cf12 push_back\cf4 (c3);\
                    \cf13 CutPrefix\cf4  c4 = cp; c4.\cf14 type\cf4  = \cf10 4\cf4 ; dynCuts.\cf12 push_back\cf4 (c4);\
                \}\
            \}\
\
        \} 
\f1\b \cf7 catch
\f0\b0 \cf4  (\cf13 IloException\cf4 & e) \{\
            \cf12 cerr\cf4  << \cf6 "CPLEX exception: "\cf4  << e << \cf12 endl\cf4 ;\
            best.\cf14 status\cf4  = \cf6 "CPLEX_Exception"\cf4 ;\
            best.\cf14 feasible\cf4  = 
\f1\b \cf7 false
\f0\b0 \cf4 ;\
        \}\
    \}\
\
    
\f1\b \cf7 return
\f0\b0 \cf4  best;\
\}\
\
\
\
\
\
\cf2 // ============================ Logging ============================\cf4 \

\f1\b \cf7 static
\f0\b0 \cf4  \cf8 string\cf4  \cf11 vecToStr\cf4 (
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 >& v) \{\
    \cf8 ostringstream\cf4  oss;\
    
\f1\b \cf7 for
\f0\b0 \cf4  (\cf8 size_t\cf4  i = \cf10 0\cf4 ; i < v.\cf12 size\cf4 (); i++) \{\
        
\f1\b \cf7 if
\f0\b0 \cf4  (i) oss << \cf6 " "\cf4 ;\
        oss << v[i];\
    \}\
    
\f1\b \cf7 return
\f0\b0 \cf4  oss.\cf12 str\cf4 ();\
\}\
\

\f1\b \cf7 static
\f0\b0 \cf4  
\f1\b \cf7 void
\f0\b0 \cf4  \cf11 writeMethodLog\cf4 (\cf8 ofstream\cf4 & f, 
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 string\cf4 & name, 
\f1\b \cf7 const
\f0\b0 \cf4  \cf13 SolveInfo\cf4 & s) \{\
    f << \cf6 "["\cf4  << name << \cf6 "]\\n"\cf4 ;\
    f << \cf6 "status="\cf4  << s.\cf14 status\cf4  << \cf6 "\\n"\cf4 ;\
    f << \cf6 "feasible="\cf4  << (s.\cf14 feasible\cf4  ? \cf10 1\cf4  : \cf10 0\cf4 ) << \cf6 "\\n"\cf4 ;\
    f << \cf12 fixed\cf4  << \cf12 setprecision\cf4 (\cf10 6\cf4 );\
    f << \cf6 "eta="\cf4  << s.\cf14 obj\cf4  << \cf6 "\\n"\cf4 ;\
    f << \cf6 "time="\cf4  << s.\cf14 time\cf4  << \cf6 "\\n"\cf4 ;\
    f << \cf6 "gap="\cf4  << s.\cf14 gap\cf4  << \cf6 "\\n"\cf4 ;\
    f << \cf6 "iters="\cf4  << s.\cf14 iters\cf4  << \cf6 "\\n"\cf4 ;\
    f << \cf6 "cuts="\cf4  << s.\cf14 cuts\cf4  << \cf6 "\\n"\cf4 ;\
    
\f1\b \cf7 if
\f0\b0 \cf4  (!s.\cf14 z\cf4 .\cf12 empty\cf4 ()) f << \cf6 "z="\cf4  << \cf14 vecToStr\cf4 (s.\cf14 z\cf4 ) << \cf6 "\\n"\cf4 ;\
    
\f1\b \cf7 if
\f0\b0 \cf4  (!s.\cf14 seq\cf4 .\cf12 empty\cf4 ()) f << \cf6 "seq="\cf4  << \cf14 vecToStr\cf4 (s.\cf14 seq\cf4 ) << \cf6 "\\n"\cf4 ;\
    f << \cf6 "\\n"\cf4 ;\
\}\
\
\cf2 // ============================ Main ============================\cf4 \

\f1\b \cf7 int
\f0\b0 \cf4  \cf11 main\cf4 () \{\
    \cf12 cout\cf4  << \cf6 "=====================================================\\n"\cf4 ;\
    \cf12 cout\cf4  << \cf6 "Seven methods compared:\\n"\cf4 ;\
    \cf12 cout\cf4  << \cf6 "  (1) MIP-P\\n"\cf4 ;\
    \cf12 cout\cf4  << \cf6 "  (2) MIP-P+VI\\n"\cf4 ;\
    \cf12 cout\cf4  << \cf6 "  (3) TwoStage(P) exact\\n"\cf4 ;\
    \cf12 cout\cf4  << \cf6 "  (4) TwoStage(P)+VI exact\\n"\cf4 ;\
    \cf12 cout\cf4  << \cf6 "  (5) MIP-T2\\n"\cf4 ;\
    \cf12 cout\cf4  << \cf6 "  (6) MIP-T2+VI\\n"\cf4 ;\
    \cf12 cout\cf4  << \cf6 "  (7) Heuristic AB improved (signed tardy build + pattern LS + tardy LS)\\n"\cf4 ;\
    \cf12 cout\cf4  << \cf6 "=====================================================\\n"\cf4 ;\
\
    \cf8 string\cf4  basePath = \cf6 "/Users/shijinwang/Desktop/MIP_P_Compare_7"\cf4 ;\
    \cf12 system\cf4 ((\cf6 "mkdir -p \\""\cf4  + basePath + \cf6 "\\""\cf4 ).\cf12 c_str\cf4 ());\
    \cf12 cout\cf4  << \cf6 "Output directory: "\cf4  << basePath << \cf6 "\\n"\cf4 ;\
\
    \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > n_values = \{\cf10 200\cf4 , \cf10 500\cf4 , \cf10 1000\cf4 \};\
    
\f1\b \cf7 int
\f0\b0 \cf4  instances_per_n = \cf10 10\cf4 ;\
    
\f1\b \cf7 double
\f0\b0 \cf4  TL = \cf10 3600\cf4 ;\
    
\f1\b \cf7 double
\f0\b0 \cf4  TF = \cf10 1.0\cf4 ;\
    
\f1\b \cf7 double
\f0\b0 \cf4  RDD = \cf10 1.0\cf4 ;\
\
    \cf8 string\cf4  csvPath = basePath + \cf6 "/results_summary.csv"\cf4 ;\
    \cf8 ofstream\cf4  csv(csvPath.\cf12 c_str\cf4 ());\
    csv << \cf6 "n,inst,TF,RDD,U_min,UB_eta,"\cf4 \
        << \cf6 "mipp_status,mipp_eta,mipp_time,mipp_gap,"\cf4 \
        << \cf6 "mippvi_status,mippvi_eta,mippvi_time,mippvi_gap,"\cf4 \
        << \cf6 "twop_status,twop_eta,twop_time,twop_iters,twop_cuts,"\cf4 \
        << \cf6 "twopvi_status,twopvi_eta,twopvi_time,twopvi_iters,twopvi_cuts,"\cf4 \
        << \cf6 "t2_status,t2_eta,t2_time,t2_gap,"\cf4 \
        << \cf6 "t2vi_status,t2vi_eta,t2vi_time,t2vi_gap,"\cf4 \
        << \cf6 "heur_status,heur_eta,heur_time\\n"\cf4 ;\
\
    
\f1\b \cf7 int
\f0\b0 \cf4  seedBase = \cf10 12345\cf4 ;\
\
    
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  n : n_values) \{\
        \cf12 cout\cf4  << \cf6 "\\n==== n="\cf4  << n << \cf6 " TF="\cf4  << TF << \cf6 " RDD="\cf4  << RDD << \cf6 " ====\\n"\cf4 ;\
\
        
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  inst = \cf10 0\cf4 ; inst < instances_per_n; inst++) \{\
            \cf12 cout\cf4  << \cf6 "\\n-- instance "\cf4  << inst << \cf6 " --\\n"\cf4 ;\
\
            \cf8 vector\cf4 <\cf13 Job\cf4 > jobs = \cf14 generateInstance_TF_RDD\cf4 (n, seedBase + inst * \cf10 100\cf4  + n * \cf10 10000\cf4 , TF, RDD);\
            \cf14 saveInstanceCSV\cf4 (basePath + \cf6 "/instance_n"\cf4  + \cf12 to_string\cf4 (n) + \cf6 "_i"\cf4  + \cf12 to_string\cf4 (inst) + \cf6 ".csv"\cf4 , jobs);\
\
            
\f1\b \cf7 auto
\f0\b0 \cf4  mo = \cf14 mooresAlgorithm\cf4 (jobs);\
            
\f1\b \cf7 int
\f0\b0 \cf4  U_min = mo.\cf12 first\cf4 ;\
            \cf13 SolveInfo\cf4  moMet = \cf14 evalSequence\cf4 (jobs, mo.\cf12 second\cf4 );\
            
\f1\b \cf7 double
\f0\b0 \cf4  UB_eta = moMet.\cf14 obj\cf4 ;\
            
\f1\b \cf7 if
\f0\b0 \cf4  (UB_eta < \cf10 0\cf4 ) UB_eta = \cf14 computeEtaUpperBound\cf4 (jobs);\
\
            \cf12 cout\cf4  << \cf6 "U_min="\cf4  << U_min << \cf6 " UB_eta(Moore)="\cf4  << UB_eta << \cf6 "\\n"\cf4 ;\
\
            \cf8 string\cf4  logPath = basePath + \cf6 "/detail_n"\cf4  + \cf12 to_string\cf4 (n) + \cf6 "_i"\cf4  + \cf12 to_string\cf4 (inst) + \cf6 ".txt"\cf4 ;\
            \cf8 ofstream\cf4  lf(logPath.\cf12 c_str\cf4 ());\
            lf << \cf6 "Instance n="\cf4  << n << \cf6 " inst="\cf4  << inst << \cf6 "\\n"\cf4 ;\
            lf << \cf6 "U_min="\cf4  << U_min << \cf6 " UB_eta="\cf4  << UB_eta << \cf6 "\\n\\n"\cf4 ;\
            \cf14 writeMethodLog\cf4 (lf, \cf6 "Moore"\cf4 , moMet);\
\
            \cf2 // 1) MIP-P\cf4 \
         \cf2 //   SolveInfo mipp = solveMIP_P(jobs, U_min, UB_eta, TL, false);\cf4 \
       \cf2 //     cout << "MIP-P:      status=" << mipp.status << " eta=" << mipp.obj << " time=" << mipp.time << " gap=" << mipp.gap << "\\n";\cf4 \
        \cf2 //    writeMethodLog(lf, "MIP-P", mipp);\cf4 \
\
            \cf2 // 2) MIP-P+VI\cf4 \
         \cf2 //  SolveInfo mippvi = solveMIP_P(jobs, U_min, UB_eta, TL, true);\cf4 \
         \cf2 //   cout << "MIP-P+VI:   status=" << mippvi.status << " eta=" << mippvi.obj << " time=" << mippvi.time << " gap=" << mippvi.gap << "\\n";\cf4 \
         \cf2 //   writeMethodLog(lf, "MIP-P+VI", mippvi);\cf4 \
\
            \cf2 // 3) TwoStage(P) exact\cf4 \
       \cf2 //     SolveInfo twop = runTwoStageP_exact(jobs, U_min, UB_eta, TL, false, false);\cf4 \
        \cf2 //    cout << "TwoStage(P):    eta=" << twop.obj << " time=" << twop.time << " status=" << twop.status << "\\n";\cf4 \
       \cf2 //     writeMethodLog(lf, "TwoStage(P)", twop);\cf4 \
\
            \cf2 // 4) TwoStage(P)+VI exact\cf4 \
         \
           \cf2 //   SolveInfo twopvi = runTwoStageP_exact(jobs, U_min, UB_eta, TL, true, true);\cf4 \
          \cf2 //    cout << "TwoStage(P)+VI: eta=" << twopvi.obj << " time=" << twopvi.time << " status=" //<< twopvi.status << "\\n";\cf4 \
           \cf2 //     writeMethodLog(lf, "TwoStage(P)+VI", twopvi);\cf4 \
        \
         \
            \cf2 // 5) MIP-T2\cf4 \
        \cf2 //    SolveInfo t2 = solveMIP_T2(jobs, U_min, UB_eta, TL, false);\cf4 \
         \cf2 //   cout << "MIP-T2:     status=" << t2.status << " eta=" << t2.obj << " time=" << t2.time << " gap=" << t2.gap << "\\n";\cf4 \
        \cf2 //    writeMethodLog(lf, "MIP-T2", t2);\cf4 \
\
            \cf2 // 6) MIP-T2+VI\cf4 \
          \cf2 //  SolveInfo t2vi = solveMIP_T2(jobs, U_min, UB_eta, TL, true);\cf4 \
          \cf2 //  cout << "MIP-T2+VI:  status=" << t2vi.status << " eta=" << t2vi.obj << " time=" << t2vi.time << " gap=" << t2vi.gap << "\\n";\cf4 \
          \cf2 //  writeMethodLog(lf, "MIP-T2+VI", t2vi);\cf4 \
\
            \cf2 // 7) Heuristic AB improved\cf4 \
            
\f1\b \cf7 double
\f0\b0 \cf4  heurTL = \cf12 min\cf4 (\cf10 60.0\cf4 , TL);\
            \cf13 SolveInfo\cf4  heur = \cf14 runHeuristicAB_improved2\cf4 (jobs, U_min, heurTL, seedBase + inst + n*\cf10 7\cf4 , \cf10 80\cf4 );\
            \cf12 cout\cf4  << \cf6 "Heuristic AB:   status="\cf4  << heur.\cf14 status\cf4  << \cf6 " eta="\cf4  << heur.\cf14 obj\cf4  << \cf6 " time="\cf4  << heur.\cf14 time\cf4  << \cf6 "\\n"\cf4 ;\
            \cf14 writeMethodLog\cf4 (lf, \cf6 "HeuristicAB"\cf4 , heur);\
            \
         \cf2 //   SolveInfo twopviparrel=runTwoStageP_exact_withHeuristicWarmStart(jobs,  heur, U_min, UB_eta, TL, true, true);\cf4 \
        \cf2 //    cout << "twopviparrel(P)+VI: eta=" << twopviparrel.obj << " time=" << twopviparrel.time << " status=" << twopviparrel.status << "\\n";\cf4 \
        \cf2 //    writeMethodLog(lf, "twopviparrel(P)+VI", twopviparrel);\cf4 \
\
            lf.\cf12 close\cf4 ();\
          \
                \
                csv << n << \cf6 ","\cf4  << inst << \cf6 ","\cf4  << TF << \cf6 ","\cf4  << RDD << \cf6 ","\cf4  << U_min << \cf6 ","\cf4  << UB_eta << \cf6 ","\cf4 \
                \cf2 //    << mipp.status << "," << mipp.obj << "," << mipp.time << "," << mipp.gap << ","\cf4 \
                 \cf2 //   << mippvi.status << "," << mippvi.obj << "," << mippvi.time << "," << mippvi.gap << ","\cf4 \
                \cf2 //    << twop.status << "," << twop.obj << "," << twop.time << "," << twop.iters << "," << twop.cuts << ","\cf4 \
               \cf2 // <<twopvi.status << "," << twopvi.obj << "," << twopvi.time << "," << //twopvi.iters << "," << twopvi.cuts << ","\cf4 \
                \cf2 //    << t2.status << "," << t2.obj << "," << t2.time << "," << t2.gap << ","\cf4 \
                \cf2 //    << t2vi.status << "," << t2vi.obj << "," << t2vi.time << "," << t2vi.gap << ","\cf4 \
                << heur.\cf14 status\cf4  << \cf6 ","\cf4  << heur.\cf14 obj\cf4  << \cf6 ","\cf4  << heur.\cf14 time\cf4 << \cf6 ","\cf4 \
              \cf2 //  << twopviparrel.status << "," << twopviparrel.obj << "," << twopviparrel.time << "," << twopviparrel.iters << "," << twopviparrel.cuts << ","\cf4 \
                << \cf6 "\\n"\cf4 ;\
         \
        \}\
    \}\
\
    csv.\cf12 close\cf4 ();\
    \cf12 cout\cf4  << \cf6 "\\nDONE. Summary CSV:\\n  "\cf4  << csvPath << \cf6 "\\n"\cf4 ;\
    
\f1\b \cf7 return
\f0\b0 \cf4  \cf10 0\cf4 ;\
\}\
}