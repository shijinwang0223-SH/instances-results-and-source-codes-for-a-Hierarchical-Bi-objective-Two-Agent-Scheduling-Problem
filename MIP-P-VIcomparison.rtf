{\rtf1\ansi\ansicpg1252\cocoartf2639
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;\f1\fnil\fcharset0 Menlo-Bold;}
{\colortbl;\red255\green255\blue255;\red93\green108\blue121;\red255\green255\blue255;\red0\green0\blue0;
\red100\green56\blue32;\red196\green26\blue22;\red155\green35\blue147;\red57\green0\blue160;\red11\green79\blue121;
\red28\green0\blue207;\red15\green104\blue160;\red108\green54\blue169;\red28\green70\blue74;\red50\green109\blue116;
}
{\*\expandedcolortbl;;\csgenericrgb\c36526\c42188\c47515;\csgenericrgb\c100000\c100000\c100000;\csgenericrgb\c0\c0\c0\c85000;
\csgenericrgb\c39147\c22031\c12446;\csgenericrgb\c77000\c10200\c8600;\csgenericrgb\c60759\c13753\c57628;\csgenericrgb\c22454\c0\c62803;\csgenericrgb\c4314\c30980\c47451;
\csgenericrgb\c11000\c0\c81000;\csgenericrgb\c5882\c40784\c62745;\csgenericrgb\c42190\c21278\c66379;\csgenericrgb\c10981\c27276\c28869;\csgenericrgb\c19418\c42935\c45455;
}
\paperw11900\paperh16840\margl1440\margr1440\vieww20520\viewh8400\viewkind0
\deftab593
\pard\tx593\pardeftab593\pardirnatural\partightenfactor0

\f0\fs24 \cf2 \cb3 /*\cf4 \
\cf2   mip_p_compare_vi.cpp\cf4 \
\cf2   ------------------------------------------------------------\cf4 \
\cf2   CPLEX 12.7 + Xcode 14.2 (clang++)\cf4 \
\cf2   Compare MIP-P performance under different combinations of valid inequalities (VIs).\cf4 \
\
\cf2   Model: single-machine sequencing with tardiness pattern z and fairness objective\cf4 \
\cf2         eta = | avg_A (w_j T_j) - avg_B (w_j T_j) |\cf4 \
\cf2   with lex constraint enforced by: sum_j z_j == U_min (EXACT).\cf4 \
\
\cf2   Output:\cf4 \
\cf2     - per-instance detail log: detail_n\{n\}_i\{inst\}.txt\cf4 \
\cf2     - summary CSV: results_summary.csv\cf4 \
\
\cf2   Notes:\cf4 \
\cf2     - Uses your robust MIP-P formulation (assignment x, cumulative S, completion C, tardiness T, binary z).\cf4 \
\cf2     - VIs:\cf4 \
\cf2         VI1: prefix lower bound on S[k] via k smallest processing times\cf4 \
\cf2         VI2: symmetry breaking for identical jobs (same agent,p,d,w)\cf4 \
\cf2         VI3: EDD prefix cover in z\cf4 \
\cf2         VI4: capacity/deadline cuts in z\cf4 \
\cf2         VI5: pairwise on-time impossibility cuts in z\cf4 \
\cf2 */\cf4 \
\
\cf5 #include \cf6 <ilcplex/ilocplex.h>\cf4 \
\cf5 #include \cf6 <algorithm>\cf4 \
\cf5 #include \cf6 <chrono>\cf4 \
\cf5 #include \cf6 <cmath>\cf4 \
\cf5 #include \cf6 <fstream>\cf4 \
\cf5 #include \cf6 <iomanip>\cf4 \
\cf5 #include \cf6 <iostream>\cf4 \
\cf5 #include \cf6 <numeric>\cf4 \
\cf5 #include \cf6 <random>\cf4 \
\cf5 #include \cf6 <sstream>\cf4 \
\cf5 #include \cf6 <string>\cf4 \
\cf5 #include \cf6 <vector>\cf4 \
\
\cf5 ILOSTLBEGIN\cf4 \

\f1\b \cf7 using
\f0\b0 \cf4  
\f1\b \cf7 namespace
\f0\b0 \cf4  \cf8 std\cf4 ;\
\
\cf2 // ---------------- Data ----------------\cf4 \

\f1\b \cf7 struct
\f0\b0 \cf4  \cf9 Job\cf4  \{\
    
\f1\b \cf7 int
\f0\b0 \cf4  id;\
    
\f1\b \cf7 int
\f0\b0 \cf4  agent; \cf2 // 0=A, 1=B\cf4 \
    
\f1\b \cf7 int
\f0\b0 \cf4  p;\
    
\f1\b \cf7 int
\f0\b0 \cf4  d;\
    
\f1\b \cf7 int
\f0\b0 \cf4  w;\
\};\
\

\f1\b \cf7 struct
\f0\b0 \cf4  \cf9 SolveInfo\cf4  \{\
    
\f1\b \cf7 bool
\f0\b0 \cf4  feasible = 
\f1\b \cf7 false
\f0\b0 \cf4 ;\
    \cf8 string\cf4  status = \cf6 "NA"\cf4 ;\
    
\f1\b \cf7 double
\f0\b0 \cf4  obj = -\cf10 1.0\cf4 ;      \cf2 // eta\cf4 \
    
\f1\b \cf7 double
\f0\b0 \cf4  time = \cf10 0.0\cf4 ;\
    
\f1\b \cf7 double
\f0\b0 \cf4  gap = \cf10 0.0\cf4 ;\
    
\f1\b \cf7 double
\f0\b0 \cf4  wTA = \cf10 0.0\cf4 ;\
    
\f1\b \cf7 double
\f0\b0 \cf4  wTB = \cf10 0.0\cf4 ;\
    \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > seq;\
    \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > z;\
\};\
\
\cf2 // ---------------- Utility ----------------\cf4 \

\f1\b \cf7 static
\f0\b0 \cf4  
\f1\b \cf7 inline
\f0\b0 \cf4  
\f1\b \cf7 double
\f0\b0 \cf4  \cf11 nowSec\cf4 () \{\
    
\f1\b \cf7 using
\f0\b0 \cf4  
\f1\b \cf7 namespace
\f0\b0 \cf4  \cf8 chrono\cf4 ;\
    
\f1\b \cf7 return
\f0\b0 \cf4  \cf8 duration\cf4 <
\f1\b \cf7 double
\f0\b0 \cf4 >(\cf8 high_resolution_clock\cf4 ::\cf12 now\cf4 ().\cf12 time_since_epoch\cf4 ()).\cf12 count\cf4 ();\
\}\
\

\f1\b \cf7 static
\f0\b0 \cf4  \cf8 string\cf4  \cf11 statusToString\cf4 (\cf13 IloCplex\cf4 & cplex) \{\
    \cf13 IloAlgorithm\cf4 ::\cf13 Status\cf4  st = cplex.\cf14 getStatus\cf4 ();\
    
\f1\b \cf7 switch
\f0\b0 \cf4  (st) \{\
        
\f1\b \cf7 case
\f0\b0 \cf4  \cf13 IloAlgorithm\cf4 ::\cf14 Optimal\cf4 : 
\f1\b \cf7 return
\f0\b0 \cf4  \cf6 "Optimal"\cf4 ;\
        
\f1\b \cf7 case
\f0\b0 \cf4  \cf13 IloAlgorithm\cf4 ::\cf14 Feasible\cf4 : 
\f1\b \cf7 return
\f0\b0 \cf4  \cf6 "Feasible"\cf4 ;\
        
\f1\b \cf7 case
\f0\b0 \cf4  \cf13 IloAlgorithm\cf4 ::\cf14 Infeasible\cf4 : 
\f1\b \cf7 return
\f0\b0 \cf4  \cf6 "Infeasible"\cf4 ;\
        
\f1\b \cf7 case
\f0\b0 \cf4  \cf13 IloAlgorithm\cf4 ::\cf14 Unbounded\cf4 : 
\f1\b \cf7 return
\f0\b0 \cf4  \cf6 "Unbounded"\cf4 ;\
        
\f1\b \cf7 case
\f0\b0 \cf4  \cf13 IloAlgorithm\cf4 ::\cf14 InfeasibleOrUnbounded\cf4 : 
\f1\b \cf7 return
\f0\b0 \cf4  \cf6 "InfOrUnb"\cf4 ;\
        
\f1\b \cf7 case
\f0\b0 \cf4  \cf13 IloAlgorithm\cf4 ::\cf14 Error\cf4 : 
\f1\b \cf7 return
\f0\b0 \cf4  \cf6 "Error"\cf4 ;\
        
\f1\b \cf7 default
\f0\b0 \cf4 : 
\f1\b \cf7 return
\f0\b0 \cf4  \cf6 "Other"\cf4 ;\
    \}\
\}\
\

\f1\b \cf7 static
\f0\b0 \cf4  
\f1\b \cf7 double
\f0\b0 \cf4  \cf11 safeGap\cf4 (\cf13 IloCplex\cf4 & cplex) \{\
    
\f1\b \cf7 try
\f0\b0 \cf4  \{\
        
\f1\b \cf7 if
\f0\b0 \cf4  (cplex.\cf14 getStatus\cf4 () == \cf13 IloAlgorithm\cf4 ::\cf14 Optimal\cf4 ) 
\f1\b \cf7 return
\f0\b0 \cf4  \cf10 0.0\cf4 ;\
        
\f1\b \cf7 if
\f0\b0 \cf4  (cplex.\cf14 getStatus\cf4 () == \cf13 IloAlgorithm\cf4 ::\cf14 Feasible\cf4 ) 
\f1\b \cf7 return
\f0\b0 \cf4  cplex.\cf14 getMIPRelativeGap\cf4 ();\
    \} 
\f1\b \cf7 catch
\f0\b0 \cf4  (...) \{\}\
    
\f1\b \cf7 return
\f0\b0 \cf4  \cf10 0.0\cf4 ;\
\}\
\

\f1\b \cf7 static
\f0\b0 \cf4  \cf8 string\cf4  \cf11 vecToStr\cf4 (
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 >& v) \{\
    \cf8 ostringstream\cf4  oss;\
    
\f1\b \cf7 for
\f0\b0 \cf4  (\cf8 size_t\cf4  i = \cf10 0\cf4 ; i < v.\cf12 size\cf4 (); i++) \{\
        
\f1\b \cf7 if
\f0\b0 \cf4  (i) oss << \cf6 " "\cf4 ;\
        oss << v[i];\
    \}\
    
\f1\b \cf7 return
\f0\b0 \cf4  oss.\cf12 str\cf4 ();\
\}\
\

\f1\b \cf7 static
\f0\b0 \cf4  
\f1\b \cf7 void
\f0\b0 \cf4  \cf11 writeMethodLog\cf4 (\cf8 ofstream\cf4 & f, 
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 string\cf4 & name, 
\f1\b \cf7 const
\f0\b0 \cf4  \cf13 SolveInfo\cf4 & s) \{\
    f << \cf6 "["\cf4  << name << \cf6 "]\\n"\cf4 ;\
    f << \cf6 "status="\cf4  << s.\cf14 status\cf4  << \cf6 "\\n"\cf4 ;\
    f << \cf6 "feasible="\cf4  << (s.\cf14 feasible\cf4  ? \cf10 1\cf4  : \cf10 0\cf4 ) << \cf6 "\\n"\cf4 ;\
    f << \cf12 fixed\cf4  << \cf12 setprecision\cf4 (\cf10 6\cf4 );\
    f << \cf6 "eta="\cf4  << s.\cf14 obj\cf4  << \cf6 "\\n"\cf4 ;\
    f << \cf6 "time="\cf4  << s.\cf14 time\cf4  << \cf6 "\\n"\cf4 ;\
    f << \cf6 "gap="\cf4  << s.\cf14 gap\cf4  << \cf6 "\\n"\cf4 ;\
    
\f1\b \cf7 if
\f0\b0 \cf4  (!s.\cf14 z\cf4 .\cf12 empty\cf4 ())   f << \cf6 "z="\cf4    << \cf14 vecToStr\cf4 (s.\cf14 z\cf4 )   << \cf6 "\\n"\cf4 ;\
    
\f1\b \cf7 if
\f0\b0 \cf4  (!s.\cf14 seq\cf4 .\cf12 empty\cf4 ()) f << \cf6 "seq="\cf4  << \cf14 vecToStr\cf4 (s.\cf14 seq\cf4 ) << \cf6 "\\n"\cf4 ;\
    f << \cf6 "\\n"\cf4 ;\
\}\
\
\cf2 // ---------------- Instance generation ----------------\cf4 \

\f1\b \cf7 static
\f0\b0 \cf4  \cf8 vector\cf4 <\cf13 Job\cf4 > \cf11 generateInstance\cf4 (
\f1\b \cf7 int
\f0\b0 \cf4  n, 
\f1\b \cf7 int
\f0\b0 \cf4  seed) \{\
    \cf8 vector\cf4 <\cf13 Job\cf4 > jobs;\
    \cf8 mt19937\cf4  rng(seed);\
    \cf8 uniform_int_distribution\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > p_dist(\cf10 1\cf4 , \cf10 100\cf4 );\
    \cf8 uniform_int_distribution\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > w_dist(\cf10 1\cf4 , \cf10 10\cf4 );\
\
    
\f1\b \cf7 int
\f0\b0 \cf4  totalP = \cf10 0\cf4 ;\
    
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  i = \cf10 0\cf4 ; i < n; i++) totalP += p_dist(rng);\
    \cf8 uniform_int_distribution\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > d_dist(\cf10 0\cf4 , (
\f1\b \cf7 int
\f0\b0 \cf4 )\cf12 floor\cf4 (totalP * \cf10 0.8\cf4 ));\
\
    jobs.\cf12 reserve\cf4 (n);\
    
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  i = \cf10 0\cf4 ; i < n; i++) \{\
        \cf13 Job\cf4  jb;\
        jb.\cf14 id\cf4  = i;\
        jb.\cf14 agent\cf4  = (i < n / \cf10 2\cf4 ) ? \cf10 0\cf4  : \cf10 1\cf4 ;\
        jb.\cf14 p\cf4  = p_dist(rng);\
        jb.\cf14 d\cf4  = d_dist(rng);\
        jb.\cf14 w\cf4  = w_dist(rng);\
        jobs.\cf12 push_back\cf4 (jb);\
    \}\
    
\f1\b \cf7 return
\f0\b0 \cf4  jobs;\
\}\
\

\f1\b \cf7 static
\f0\b0 \cf4  
\f1\b \cf7 void
\f0\b0 \cf4  \cf11 saveInstanceCSV\cf4 (
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 string\cf4 & path, 
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 vector\cf4 <\cf13 Job\cf4 >& jobs) \{\
    \cf8 ofstream\cf4  f(path.\cf12 c_str\cf4 ());\
    f << \cf6 "ID,Agent,p,d,w\\n"\cf4 ;\
    
\f1\b \cf7 for
\f0\b0 \cf4  (\cf8 size_t\cf4  i = \cf10 0\cf4 ; i < jobs.\cf12 size\cf4 (); i++) \{\
        f << jobs[i].\cf14 id\cf4  << \cf6 ","\cf4  << jobs[i].\cf14 agent\cf4  << \cf6 ","\cf4 \
          << jobs[i].\cf14 p\cf4  << \cf6 ","\cf4  << jobs[i].\cf14 d\cf4  << \cf6 ","\cf4  << jobs[i].\cf14 w\cf4  << \cf6 "\\n"\cf4 ;\
    \}\
\}\
\
\cf2 // Evaluate a given permutation (used for Moore UB)\cf4 \

\f1\b \cf7 static
\f0\b0 \cf4  \cf13 SolveInfo\cf4  \cf11 evalSequence\cf4 (
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 vector\cf4 <\cf13 Job\cf4 >& jobs, 
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 >& seq) \{\
    
\f1\b \cf7 int
\f0\b0 \cf4  n = (
\f1\b \cf7 int
\f0\b0 \cf4 )jobs.\cf12 size\cf4 ();\
    \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > C(n, \cf10 0\cf4 );\
    
\f1\b \cf7 int
\f0\b0 \cf4  t = \cf10 0\cf4 ;\
    
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  k = \cf10 0\cf4 ; k < n; k++) \{\
        
\f1\b \cf7 int
\f0\b0 \cf4  j = seq[k];\
        t += jobs[j].\cf14 p\cf4 ;\
        C[j] = t;\
    \}\
\
    
\f1\b \cf7 int
\f0\b0 \cf4  nA = \cf10 0\cf4 , nB = \cf10 0\cf4 ;\
    
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) (jobs[j].\cf14 agent\cf4  == \cf10 0\cf4  ? nA : nB)++;\
\
    
\f1\b \cf7 double
\f0\b0 \cf4  sumA = \cf10 0.0\cf4 , sumB = \cf10 0.0\cf4 ;\
    \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > z(n, \cf10 0\cf4 );\
    
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) \{\
        
\f1\b \cf7 int
\f0\b0 \cf4  Tj = \cf12 max\cf4 (\cf10 0\cf4 , C[j] - jobs[j].\cf14 d\cf4 );\
        
\f1\b \cf7 if
\f0\b0 \cf4  (C[j] > jobs[j].\cf14 d\cf4 ) z[j] = \cf10 1\cf4 ;\
        
\f1\b \cf7 if
\f0\b0 \cf4  (jobs[j].\cf14 agent\cf4  == \cf10 0\cf4 ) sumA += jobs[j].\cf14 w\cf4  * (
\f1\b \cf7 double
\f0\b0 \cf4 )Tj;\
        
\f1\b \cf7 else
\f0\b0 \cf4  sumB += jobs[j].\cf14 w\cf4  * (
\f1\b \cf7 double
\f0\b0 \cf4 )Tj;\
    \}\
\
    \cf13 SolveInfo\cf4  si;\
    si.\cf14 feasible\cf4  = 
\f1\b \cf7 true
\f0\b0 \cf4 ;\
    si.\cf14 status\cf4  = \cf6 "SEQ"\cf4 ;\
    si.\cf14 seq\cf4  = seq;\
    si.\cf14 z\cf4  = z;\
    si.\cf14 wTA\cf4  = (nA ? sumA / nA : \cf10 0.0\cf4 );\
    si.\cf14 wTB\cf4  = (nB ? sumB / nB : \cf10 0.0\cf4 );\
    si.\cf14 obj\cf4  = \cf12 fabs\cf4 (si.\cf14 wTA\cf4  - si.\cf14 wTB\cf4 );\
    
\f1\b \cf7 return
\f0\b0 \cf4  si;\
\}\
\
\cf2 // Moore's algorithm for 1||sum Uj gives min tardy count and an UB sequence\cf4 \

\f1\b \cf7 static
\f0\b0 \cf4  \cf8 pair\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 , \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 >> \cf11 mooresAlgorithm\cf4 (
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 vector\cf4 <\cf13 Job\cf4 >& jobs) \{\
    \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > idx(jobs.\cf12 size\cf4 ());\
    
\f1\b \cf7 for
\f0\b0 \cf4  (\cf8 size_t\cf4  i = \cf10 0\cf4 ; i < jobs.\cf12 size\cf4 (); i++) idx[i] = (
\f1\b \cf7 int
\f0\b0 \cf4 )i;\
\
    \cf12 sort\cf4 (idx.\cf12 begin\cf4 (), idx.\cf12 end\cf4 (), [&](
\f1\b \cf7 int
\f0\b0 \cf4  a, 
\f1\b \cf7 int
\f0\b0 \cf4  b) \{ 
\f1\b \cf7 return
\f0\b0 \cf4  jobs[a].\cf14 d\cf4  < jobs[b].\cf14 d\cf4 ; \});\
\
    \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > onTime, removed;\
    
\f1\b \cf7 int
\f0\b0 \cf4  t = \cf10 0\cf4 ;\
    
\f1\b \cf7 for
\f0\b0 \cf4  (\cf8 size_t\cf4  r = \cf10 0\cf4 ; r < idx.\cf12 size\cf4 (); r++) \{\
        
\f1\b \cf7 int
\f0\b0 \cf4  j = idx[r];\
        onTime.\cf12 push_back\cf4 (j);\
        t += jobs[j].\cf14 p\cf4 ;\
        
\f1\b \cf7 if
\f0\b0 \cf4  (t > jobs[j].\cf14 d\cf4 ) \{\
            
\f1\b \cf7 int
\f0\b0 \cf4  arg = onTime[\cf10 0\cf4 ];\
            
\f1\b \cf7 for
\f0\b0 \cf4  (\cf8 size_t\cf4  u = \cf10 1\cf4 ; u < onTime.\cf12 size\cf4 (); u++) \{\
                
\f1\b \cf7 if
\f0\b0 \cf4  (jobs[onTime[\cf12 u\cf4 ]].\cf14 p\cf4  > jobs[arg].\cf14 p\cf4 ) arg = onTime[u];\
            \}\
            removed.\cf12 push_back\cf4 (arg);\
            t -= jobs[arg].\cf14 p\cf4 ;\
            onTime.\cf12 erase\cf4 (\cf12 remove\cf4 (onTime.\cf12 begin\cf4 (), onTime.\cf12 end\cf4 (), arg), onTime.\cf12 end\cf4 ());\
        \}\
    \}\
    \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > seq;\
    
\f1\b \cf7 for
\f0\b0 \cf4  (\cf8 size_t\cf4  i = \cf10 0\cf4 ; i < onTime.\cf12 size\cf4 (); i++) seq.\cf12 push_back\cf4 (onTime[i]);\
    
\f1\b \cf7 for
\f0\b0 \cf4  (\cf8 size_t\cf4  i = \cf10 0\cf4 ; i < removed.\cf12 size\cf4 (); i++) seq.\cf12 push_back\cf4 (removed[i]);\
    
\f1\b \cf7 return
\f0\b0 \cf4  \cf12 make_pair\cf4 ((
\f1\b \cf7 int
\f0\b0 \cf4 )removed.\cf12 size\cf4 (), seq);\
\}\
\
\cf2 // ---------------- Big-M and core modeling helpers ----------------\cf4 \

\f1\b \cf7 struct
\f0\b0 \cf4  \cf9 BigMData\cf4  \{\
    
\f1\b \cf7 int
\f0\b0 \cf4  P = \cf10 0\cf4 ;\
    
\f1\b \cf7 double
\f0\b0 \cf4  M = \cf10 0.0\cf4 ;\
    \cf8 vector\cf4 <
\f1\b \cf7 double
\f0\b0 \cf4 > Mj;\
    \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > alwaysOnTime; \cf2 // if d_j >= P => cannot be tardy in any sequence\cf4 \
\};\
\

\f1\b \cf7 static
\f0\b0 \cf4  \cf13 BigMData\cf4  \cf11 computeBigM\cf4 (
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 vector\cf4 <\cf13 Job\cf4 >& jobs) \{\
    \cf13 BigMData\cf4  bm;\
    
\f1\b \cf7 int
\f0\b0 \cf4  n = (
\f1\b \cf7 int
\f0\b0 \cf4 )jobs.\cf12 size\cf4 ();\
    bm.\cf14 P\cf4  = \cf10 0\cf4 ;\
    
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) bm.\cf14 P\cf4  += jobs[j].\cf14 p\cf4 ;\
    bm.\cf14 M\cf4  = (
\f1\b \cf7 double
\f0\b0 \cf4 )bm.\cf14 P\cf4 ;\
\
    bm.\cf14 Mj\cf4 .\cf12 assign\cf4 (n, \cf10 0.0\cf4 );\
    bm.\cf14 alwaysOnTime\cf4 .\cf12 assign\cf4 (n, \cf10 0\cf4 );\
    
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) \{\
        
\f1\b \cf7 if
\f0\b0 \cf4  (jobs[j].\cf14 d\cf4  >= bm.\cf14 P\cf4 ) \{\
            bm.\cf14 alwaysOnTime\cf4 [j] = \cf10 1\cf4 ;\
            bm.\cf12 Mj\cf4 [j] = \cf10 0.0\cf4 ;\
        \} 
\f1\b \cf7 else
\f0\b0 \cf4  \{\
            bm.\cf14 alwaysOnTime\cf4 [j] = \cf10 0\cf4 ;\
            bm.\cf12 Mj\cf4 [j] = \cf12 max\cf4 (\cf10 1.0\cf4 , (
\f1\b \cf7 double
\f0\b0 \cf4 )bm.\cf14 P\cf4  - (
\f1\b \cf7 double
\f0\b0 \cf4 )jobs[j].\cf14 d\cf4 );\
        \}\
    \}\
    
\f1\b \cf7 return
\f0\b0 \cf4  bm;\
\}\
\

\f1\b \cf7 static
\f0\b0 \cf4  
\f1\b \cf7 void
\f0\b0 \cf4  \cf11 addEtaConstraints\cf4 (\cf13 IloEnv\cf4 & env, \cf13 IloModel\cf4 & model, 
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 vector\cf4 <\cf13 Job\cf4 >& jobs,\
                              
\f1\b \cf7 const
\f0\b0 \cf4  \cf13 IloNumVarArray\cf4 & T, \cf13 IloNumVar\cf4 & eta)\
\{\
    
\f1\b \cf7 int
\f0\b0 \cf4  n = (
\f1\b \cf7 int
\f0\b0 \cf4 )jobs.\cf12 size\cf4 ();\
    
\f1\b \cf7 int
\f0\b0 \cf4  nA = \cf10 0\cf4 , nB = \cf10 0\cf4 ;\
    
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) (jobs[j].\cf14 agent\cf4  == \cf10 0\cf4  ? nA : nB)++;\
\
    \cf13 IloExpr\cf4  diff(env);\
    
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) \{\
        
\f1\b \cf7 double
\f0\b0 \cf4  coeff = (jobs[j].\cf14 agent\cf4  == \cf10 0\cf4  ? (
\f1\b \cf7 double
\f0\b0 \cf4 )jobs[j].\cf14 w\cf4  / (
\f1\b \cf7 double
\f0\b0 \cf4 )nA\
                                           : -(
\f1\b \cf7 double
\f0\b0 \cf4 )jobs[j].\cf14 w\cf4  / (
\f1\b \cf7 double
\f0\b0 \cf4 )nB);\
        diff += coeff * T[j];\
    \}\
    model.\cf14 add\cf4 (eta >= diff);\
    model.\cf14 add\cf4 (eta >= -diff);\
    diff.\cf14 end\cf4 ();\
\}\
\

\f1\b \cf7 static
\f0\b0 \cf4  
\f1\b \cf7 void
\f0\b0 \cf4  \cf11 addAssignmentAndCumulativeS\cf4 (\cf13 IloEnv\cf4 & env, \cf13 IloModel\cf4 & model, 
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 vector\cf4 <\cf13 Job\cf4 >& jobs,\
                                       \cf13 IloArray\cf4 <\cf13 IloBoolVarArray\cf4 >& x, \cf13 IloNumVarArray\cf4 & S)\
\{\
    
\f1\b \cf7 int
\f0\b0 \cf4  n = (
\f1\b \cf7 int
\f0\b0 \cf4 )jobs.\cf12 size\cf4 ();\
\
    
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  k = \cf10 0\cf4 ; k < n; k++) \{\
        \cf13 IloExpr\cf4  sum(env);\
        
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) sum += x[\cf14 j\cf4 ][k];\
        model.\cf14 add\cf4 (sum == \cf10 1\cf4 );\
        sum.\cf14 end\cf4 ();\
    \}\
    
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) \{\
        \cf13 IloExpr\cf4  sum(env);\
        
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  k = \cf10 0\cf4 ; k < n; k++) sum += x[\cf14 j\cf4 ][k];\
        model.\cf14 add\cf4 (sum == \cf10 1\cf4 );\
        sum.\cf14 end\cf4 ();\
    \}\
\
    \cf2 // S[0] = sum p_j x_\{j0\}\cf4 \
    \{\
        \cf13 IloExpr\cf4  s0(env);\
        
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) s0 += jobs[j].\cf14 p\cf4  * x[\cf14 j\cf4 ][\cf10 0\cf4 ];\
        model.\cf14 add\cf4 (S[\cf10 0\cf4 ] == s0);\
        s0.\cf14 end\cf4 ();\
    \}\
    \cf2 // S[k] = S[k-1] + sum p_j x_\{jk\}\cf4 \
    
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  k = \cf10 1\cf4 ; k < n; k++) \{\
        \cf13 IloExpr\cf4  sk(env);\
        
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) sk += jobs[j].\cf14 p\cf4  * x[\cf14 j\cf4 ][k];\
        model.\cf14 add\cf4 (S[k] == S[k - \cf10 1\cf4 ] + sk);\
        sk.\cf14 end\cf4 ();\
    \}\
\}\
\

\f1\b \cf7 static
\f0\b0 \cf4  
\f1\b \cf7 void
\f0\b0 \cf4  \cf11 linkCompletionTimes\cf4 (\cf13 IloEnv\cf4 & env, \cf13 IloModel\cf4 & model, 
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 vector\cf4 <\cf13 Job\cf4 >& jobs,\
                               \cf13 IloArray\cf4 <\cf13 IloBoolVarArray\cf4 >& x, 
\f1\b \cf7 const
\f0\b0 \cf4  \cf13 IloNumVarArray\cf4 & S,\
                               \cf13 IloNumVarArray\cf4 & C, 
\f1\b \cf7 double
\f0\b0 \cf4  M)\
\{\
    
\f1\b \cf7 int
\f0\b0 \cf4  n = (
\f1\b \cf7 int
\f0\b0 \cf4 )jobs.\cf12 size\cf4 ();\
    
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) \{\
        
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  k = \cf10 0\cf4 ; k < n; k++) \{\
            model.\cf14 add\cf4 (C[j] >= S[k] - M * (\cf10 1\cf4  - x[\cf14 j\cf4 ][k]));\
            model.\cf14 add\cf4 (C[j] <= S[k] + M * (\cf10 1\cf4  - x[\cf14 j\cf4 ][k]));\
        \}\
    \}\
\}\
\
\cf2 // Robust tardiness linearization with z\cf4 \

\f1\b \cf7 static
\f0\b0 \cf4  
\f1\b \cf7 void
\f0\b0 \cf4  \cf11 addTardinessLogic\cf4 (\cf13 IloEnv\cf4 & env, \cf13 IloModel\cf4 & model, 
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 vector\cf4 <\cf13 Job\cf4 >& jobs,\
                             
\f1\b \cf7 const
\f0\b0 \cf4  \cf13 BigMData\cf4 & bm,\
                             \cf13 IloNumVarArray\cf4 & C, \cf13 IloNumVarArray\cf4 & T, \cf13 IloBoolVarArray\cf4 & z)\
\{\
    
\f1\b \cf7 int
\f0\b0 \cf4  n = (
\f1\b \cf7 int
\f0\b0 \cf4 )jobs.\cf12 size\cf4 ();\
    
\f1\b \cf7 double
\f0\b0 \cf4  eps = \cf10 1e-6\cf4 ;\
\
    
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) \{\
        
\f1\b \cf7 if
\f0\b0 \cf4  (bm.\cf14 alwaysOnTime\cf4 [j]) \{\
            model.\cf14 add\cf4 (z[j] == \cf10 0\cf4 );\
            model.\cf14 add\cf4 (T[j] == \cf10 0\cf4 );\
            model.\cf14 add\cf4 (C[j] <= jobs[j].\cf14 d\cf4 );\
        \} 
\f1\b \cf7 else
\f0\b0 \cf4  \{\
            
\f1\b \cf7 double
\f0\b0 \cf4  Mj = bm.\cf14 P\cf4 ;\
\
            model.\cf14 add\cf4 (T[j] >= C[j] - jobs[j].\cf14 d\cf4 );\
            model.\cf14 add\cf4 (T[j] >= \cf10 0\cf4 );\
\
            model.\cf14 add\cf4 (T[j] <= (C[j] - jobs[j].\cf14 d\cf4 ) + Mj * (\cf10 1\cf4  - z[j]));\
            model.\cf14 add\cf4 (T[j] <= Mj * z[j]);\
\
            \cf2 // region separation\cf4 \
            model.\cf14 add\cf4 (C[j] <= jobs[j].\cf14 d\cf4  + Mj * z[j]);\
            model.\cf14 add\cf4 (C[j] >= jobs[j].\cf14 d\cf4  - Mj * (\cf10 1\cf4  - z[j]));\
\
            \cf2 // strictness for tardy when z=1\cf4 \
            model.\cf14 add\cf4 (C[j] >= jobs[j].\cf14 d\cf4  + eps - Mj * (\cf10 1\cf4  - z[j]));\
        \}\
    \}\
\}\
\

\f1\b \cf7 static
\f0\b0 \cf4  
\f1\b \cf7 void
\f0\b0 \cf4  \cf11 extractSeqFromX\cf4 (\cf13 IloCplex\cf4 & cplex, 
\f1\b \cf7 const
\f0\b0 \cf4  \cf13 IloArray\cf4 <\cf13 IloBoolVarArray\cf4 >& x, \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 >& seqOut) \{\
    
\f1\b \cf7 int
\f0\b0 \cf4  n = (
\f1\b \cf7 int
\f0\b0 \cf4 )seqOut.\cf12 size\cf4 ();\
    
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  k = \cf10 0\cf4 ; k < n; k++) \{\
        seqOut[k] = -\cf10 1\cf4 ;\
        
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) \{\
            
\f1\b \cf7 if
\f0\b0 \cf4  (cplex.\cf14 getValue\cf4 (x[\cf14 j\cf4 ][k]) > \cf10 0.5\cf4 ) \{ seqOut[k] = j; 
\f1\b \cf7 break
\f0\b0 \cf4 ; \}\
        \}\
    \}\
\}\
\
\cf2 // ---------------- VIs ----------------\cf4 \

\f1\b \cf7 struct
\f0\b0 \cf4  \cf9 VIFlags\cf4  \{\
    
\f1\b \cf7 bool
\f0\b0 \cf4  VI1_prefix_S_lb = 
\f1\b \cf7 false
\f0\b0 \cf4 ;\
    
\f1\b \cf7 bool
\f0\b0 \cf4  VI2_sym_identical = 
\f1\b \cf7 false
\f0\b0 \cf4 ;\
    
\f1\b \cf7 bool
\f0\b0 \cf4  VI3_edd_prefix_cover = 
\f1\b \cf7 false
\f0\b0 \cf4 ;\
    
\f1\b \cf7 bool
\f0\b0 \cf4  VI4_capacity_deadlines = 
\f1\b \cf7 false
\f0\b0 \cf4 ;\
    
\f1\b \cf7 bool
\f0\b0 \cf4  VI5_pairwise = 
\f1\b \cf7 false
\f0\b0 \cf4 ;\
\};\
\

\f1\b \cf7 static
\f0\b0 \cf4  \cf13 VIFlags\cf4  \cf11 makeVIConfig\cf4 (
\f1\b \cf7 bool
\f0\b0 \cf4  vi1, 
\f1\b \cf7 bool
\f0\b0 \cf4  vi2, 
\f1\b \cf7 bool
\f0\b0 \cf4  vi3, 
\f1\b \cf7 bool
\f0\b0 \cf4  vi4, 
\f1\b \cf7 bool
\f0\b0 \cf4  vi5) \{\
    \cf13 VIFlags\cf4  vf;\
    vf.\cf14 VI1_prefix_S_lb\cf4  = vi1;\
    vf.\cf14 VI2_sym_identical\cf4  = vi2;\
    vf.\cf14 VI3_edd_prefix_cover\cf4  = vi3;\
    vf.\cf14 VI4_capacity_deadlines\cf4  = vi4;\
    vf.\cf14 VI5_pairwise\cf4  = vi5;\
    
\f1\b \cf7 return
\f0\b0 \cf4  vf;\
\}\
\

\f1\b \cf7 static
\f0\b0 \cf4  \cf8 string\cf4  \cf11 viName\cf4 (
\f1\b \cf7 const
\f0\b0 \cf4  \cf13 VIFlags\cf4 & v) \{\
    \cf2 // compact label, e.g., "VI1+VI3+VI5" or "NONE"\cf4 \
    \cf8 vector\cf4 <\cf8 string\cf4 > parts;\
    
\f1\b \cf7 if
\f0\b0 \cf4  (v.\cf14 VI1_prefix_S_lb\cf4 ) parts.\cf12 push_back\cf4 (\cf6 "VI1"\cf4 );\
    
\f1\b \cf7 if
\f0\b0 \cf4  (v.\cf14 VI2_sym_identical\cf4 ) parts.\cf12 push_back\cf4 (\cf6 "VI2"\cf4 );\
    
\f1\b \cf7 if
\f0\b0 \cf4  (v.\cf14 VI3_edd_prefix_cover\cf4 ) parts.\cf12 push_back\cf4 (\cf6 "VI3"\cf4 );\
    
\f1\b \cf7 if
\f0\b0 \cf4  (v.\cf14 VI4_capacity_deadlines\cf4 ) parts.\cf12 push_back\cf4 (\cf6 "VI4"\cf4 );\
    
\f1\b \cf7 if
\f0\b0 \cf4  (v.\cf14 VI5_pairwise\cf4 ) parts.\cf12 push_back\cf4 (\cf6 "VI5"\cf4 );\
    
\f1\b \cf7 if
\f0\b0 \cf4  (parts.\cf12 empty\cf4 ()) 
\f1\b \cf7 return
\f0\b0 \cf4  \cf6 "NONE"\cf4 ;\
    \cf8 string\cf4  s = parts[\cf10 0\cf4 ];\
    
\f1\b \cf7 for
\f0\b0 \cf4  (\cf8 size_t\cf4  i = \cf10 1\cf4 ; i < parts.\cf12 size\cf4 (); i++) s += \cf6 "+"\cf4  + parts[i];\
    
\f1\b \cf7 return
\f0\b0 \cf4  s;\
\}\
\

\f1\b \cf7 static
\f0\b0 \cf4  
\f1\b \cf7 void
\f0\b0 \cf4  \cf11 addVI_MIP_P\cf4 (\cf13 IloEnv\cf4 & env, \cf13 IloModel\cf4 & model, 
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 vector\cf4 <\cf13 Job\cf4 >& jobs,\
                       
\f1\b \cf7 const
\f0\b0 \cf4  \cf13 IloArray\cf4 <\cf13 IloBoolVarArray\cf4 >& x,\
                       
\f1\b \cf7 const
\f0\b0 \cf4  \cf13 IloNumVarArray\cf4 & S,\
                       
\f1\b \cf7 const
\f0\b0 \cf4  \cf13 IloBoolVarArray\cf4 & z,\
                       
\f1\b \cf7 const
\f0\b0 \cf4  \cf13 VIFlags\cf4 & f)\
\{\
    
\f1\b \cf7 int
\f0\b0 \cf4  n = (
\f1\b \cf7 int
\f0\b0 \cf4 )jobs.\cf12 size\cf4 ();\
\
    \cf2 // VI1: prefix S lower bound by k smallest p's\cf4 \
    
\f1\b \cf7 if
\f0\b0 \cf4  (f.\cf14 VI1_prefix_S_lb\cf4 ) \{\
        \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > ps(n);\
        
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) ps[j] = jobs[j].\cf14 p\cf4 ;\
        \cf12 sort\cf4 (ps.\cf12 begin\cf4 (), ps.\cf12 end\cf4 ());\
        
\f1\b \cf7 int
\f0\b0 \cf4  run = \cf10 0\cf4 ;\
        
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  k = \cf10 0\cf4 ; k < n; k++) \{\
            run += ps[k];\
            model.\cf14 add\cf4 (S[k] >= run);\
        \}\
    \}\
\
    \cf2 // VI2: symmetry breaking for identical jobs\cf4 \
    
\f1\b \cf7 if
\f0\b0 \cf4  (f.\cf14 VI2_sym_identical\cf4 ) \{\
        
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  i = \cf10 0\cf4 ; i < n; i++) \{\
            
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = i + \cf10 1\cf4 ; j < n; j++) \{\
                
\f1\b \cf7 if
\f0\b0 \cf4  (jobs[i].\cf14 agent\cf4  == jobs[j].\cf14 agent\cf4  &&\
                    jobs[i].\cf14 p\cf4  == jobs[j].\cf14 p\cf4  &&\
                    jobs[i].\cf14 d\cf4  == jobs[j].\cf14 d\cf4  &&\
                    jobs[i].\cf14 w\cf4  == jobs[j].\cf14 w\cf4 )\
                \{\
                    \cf13 IloExpr\cf4  posi(env), posj(env);\
                    
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  k = \cf10 0\cf4 ; k < n; k++) \{\
                        posi += (k + \cf10 1\cf4 ) * x[\cf14 i\cf4 ][k];\
                        posj += (k + \cf10 1\cf4 ) * x[\cf14 j\cf4 ][k];\
                    \}\
                    model.\cf14 add\cf4 (posi <= posj);\
                    posi.\cf14 end\cf4 (); posj.\cf14 end\cf4 ();\
                \}\
            \}\
        \}\
    \}\
\
    \cf2 // VI3: EDD prefix cover in z\cf4 \
    
\f1\b \cf7 if
\f0\b0 \cf4  (f.\cf14 VI3_edd_prefix_cover\cf4 ) \{\
        \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > idx(n);\
        \cf12 iota\cf4 (idx.\cf12 begin\cf4 (), idx.\cf12 end\cf4 (), \cf10 0\cf4 );\
        \cf12 sort\cf4 (idx.\cf12 begin\cf4 (), idx.\cf12 end\cf4 (), [&](
\f1\b \cf7 int
\f0\b0 \cf4  a, 
\f1\b \cf7 int
\f0\b0 \cf4  b)\{ 
\f1\b \cf7 return
\f0\b0 \cf4  jobs[a].\cf14 d\cf4  < jobs[b].\cf14 d\cf4 ; \});\
\
        
\f1\b \cf7 int
\f0\b0 \cf4  sumP = \cf10 0\cf4 ;\
        
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  r = \cf10 0\cf4 ; r < n; r++) \{\
            sumP += jobs[idx[\cf12 r\cf4 ]].\cf14 p\cf4 ;\
            
\f1\b \cf7 if
\f0\b0 \cf4  (sumP > jobs[idx[\cf12 r\cf4 ]].\cf14 d\cf4 ) \{\
                \cf13 IloExpr\cf4  cover(env);\
                
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  i = \cf10 0\cf4 ; i <= r; i++) cover += z[idx[\cf14 i\cf4 ]];\
                model.\cf14 add\cf4 (cover >= \cf10 1\cf4 );\
                cover.\cf14 end\cf4 ();\
            \}\
        \}\
    \}\
\
    \cf2 // VI4: capacity deadlines in z\cf4 \
    
\f1\b \cf7 if
\f0\b0 \cf4  (f.\cf14 VI4_capacity_deadlines\cf4 ) \{\
        \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > Ds;\
        Ds.\cf12 reserve\cf4 (n);\
        
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) Ds.\cf12 push_back\cf4 (jobs[j].\cf14 d\cf4 );\
        \cf12 sort\cf4 (Ds.\cf12 begin\cf4 (), Ds.\cf12 end\cf4 ());\
        Ds.\cf12 erase\cf4 (\cf12 unique\cf4 (Ds.\cf12 begin\cf4 (), Ds.\cf12 end\cf4 ()), Ds.\cf12 end\cf4 ());\
\
        
\f1\b \cf7 for
\f0\b0 \cf4  (\cf8 size_t\cf4  t = \cf10 0\cf4 ; t < Ds.\cf12 size\cf4 (); t++) \{\
            
\f1\b \cf7 int
\f0\b0 \cf4  D = Ds[t];\
            \cf13 IloExpr\cf4  cap(env);\
            
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) \{\
                
\f1\b \cf7 if
\f0\b0 \cf4  (jobs[j].\cf14 d\cf4  <= D) cap += jobs[j].\cf14 p\cf4  * (\cf10 1\cf4  - z[j]);\
            \}\
            model.\cf14 add\cf4 (cap <= D);\
            cap.\cf14 end\cf4 ();\
        \}\
    \}\
\
    \cf2 // VI5: pairwise (very coarse but valid) on-time impossibility cut\cf4 \
    
\f1\b \cf7 if
\f0\b0 \cf4  (f.\cf14 VI5_pairwise\cf4 ) \{\
        
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  i = \cf10 0\cf4 ; i < n; i++) \{\
            
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = i + \cf10 1\cf4 ; j < n; j++) \{\
                
\f1\b \cf7 int
\f0\b0 \cf4  di = jobs[i].\cf14 d\cf4 , dj = jobs[j].\cf14 d\cf4 ;\
                
\f1\b \cf7 if
\f0\b0 \cf4  (jobs[i].\cf14 p\cf4  + jobs[j].\cf14 p\cf4  > \cf12 max\cf4 (di, dj)) \{\
                    model.\cf14 add\cf4 (z[i] + z[j] >= \cf10 1\cf4 );\
                \}\
            \}\
        \}\
    \}\
\}\
\
\cf2 // ---------------- MIP-P solver with arbitrary VI combination ----------------\cf4 \

\f1\b \cf7 static
\f0\b0 \cf4  \cf13 SolveInfo\cf4  \cf11 solveMIP_P_withVIFlags\cf4 (
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 vector\cf4 <\cf13 Job\cf4 >& jobs,\
                                       
\f1\b \cf7 int
\f0\b0 \cf4  U_min,\
                                       
\f1\b \cf7 double
\f0\b0 \cf4  UB_eta,\
                                       
\f1\b \cf7 double
\f0\b0 \cf4  timeLimit,\
                                       
\f1\b \cf7 const
\f0\b0 \cf4  \cf13 VIFlags\cf4 & vf)\
\{\
    \cf13 SolveInfo\cf4  out;\
    
\f1\b \cf7 double
\f0\b0 \cf4  t0 = \cf14 nowSec\cf4 ();\
    
\f1\b \cf7 int
\f0\b0 \cf4  n = (
\f1\b \cf7 int
\f0\b0 \cf4 )jobs.\cf12 size\cf4 ();\
    \cf13 BigMData\cf4  bm = \cf14 computeBigM\cf4 (jobs);\
\
    \cf2 // cannot force tardy on always-on-time jobs\cf4 \
    
\f1\b \cf7 int
\f0\b0 \cf4  alwaysCnt = \cf10 0\cf4 ;\
    
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) 
\f1\b \cf7 if
\f0\b0 \cf4  (bm.\cf14 alwaysOnTime\cf4 [j]) alwaysCnt++;\
    
\f1\b \cf7 if
\f0\b0 \cf4  (U_min > n - alwaysCnt) \{\
        out.\cf14 feasible\cf4  = 
\f1\b \cf7 false
\f0\b0 \cf4 ;\
        out.\cf14 status\cf4  = \cf6 "PreInfeasible(U_min too large)"\cf4 ;\
        out.\cf14 time\cf4  = \cf14 nowSec\cf4 () - t0;\
        
\f1\b \cf7 return
\f0\b0 \cf4  out;\
    \}\
\
    
\f1\b \cf7 try
\f0\b0 \cf4  \{\
        \cf13 IloEnv\cf4  env;\
        \cf13 IloModel\cf4  model(env);\
\
        \cf13 IloArray\cf4 <\cf13 IloBoolVarArray\cf4 > x(env, n);\
        
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) x[j] = \cf13 IloBoolVarArray\cf4 (env, n);\
\
        \cf13 IloNumVarArray\cf4  S(env, n, \cf10 0.0\cf4 , \cf5 IloInfinity\cf4 );\
        \cf13 IloNumVarArray\cf4  C(env, n, \cf10 0.0\cf4 , \cf5 IloInfinity\cf4 );\
        \cf13 IloNumVarArray\cf4  T(env, n, \cf10 0.0\cf4 , \cf5 IloInfinity\cf4 );\
        \cf13 IloBoolVarArray\cf4  z(env, n);\
        \cf13 IloNumVar\cf4  eta(env, \cf10 0.0\cf4 , \cf5 IloInfinity\cf4 );\
\
        model.\cf14 add\cf4 (\cf14 IloMinimize\cf4 (env, eta));\
\
        \cf14 addAssignmentAndCumulativeS\cf4 (env, model, jobs, x, S);\
        \cf14 linkCompletionTimes\cf4 (env, model, jobs, x, S, C, bm.\cf14 M\cf4 );\
        \cf14 addTardinessLogic\cf4 (env, model, jobs, bm, C, T, z);\
\
        \cf2 // EXACT U_min\cf4 \
        \{\
            \cf13 IloExpr\cf4  sumz(env);\
            
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) sumz += z[j];\
            model.\cf14 add\cf4 (sumz == U_min);\
            sumz.\cf14 end\cf4 ();\
        \}\
\
        \cf14 addEtaConstraints\cf4 (env, model, jobs, T, eta);\
\
        \cf2 // UB cutoff (from Moore)\cf4 \
        
\f1\b \cf7 if
\f0\b0 \cf4  (UB_eta < \cf10 1e100\cf4 ) model.\cf14 add\cf4 (eta <= UB_eta + \cf10 1e-6\cf4 );\
\
        \cf2 // Add chosen VIs\cf4 \
        \cf14 addVI_MIP_P\cf4 (env, model, jobs, x, S, z, vf);\
\
        \cf13 IloCplex\cf4  cplex(model);\
        cplex.\cf14 setParam\cf4 (\cf13 IloCplex\cf4 ::\cf13 Param\cf4 ::\cf14 TimeLimit\cf4 , timeLimit);\
        cplex.\cf14 setParam\cf4 (\cf13 IloCplex\cf4 ::\cf13 Param\cf4 ::\cf14 Threads\cf4 , \cf10 1\cf4 );\
        cplex.\cf14 setParam\cf4 (\cf13 IloCplex\cf4 ::\cf13 Param\cf4 ::\cf13 MIP\cf4 ::\cf14 Display\cf4 , \cf10 0\cf4 );\
        cplex.\cf14 setOut\cf4 (env.\cf14 getNullStream\cf4 ());\
\
        
\f1\b \cf7 bool
\f0\b0 \cf4  ok = cplex.\cf14 solve\cf4 ();\
        out.\cf14 time\cf4  = \cf14 nowSec\cf4 () - t0;\
        out.\cf14 status\cf4  = ok ? \cf14 statusToString\cf4 (cplex) : \cf6 "NoSolve"\cf4 ;\
        out.\cf14 gap\cf4  = ok ? \cf14 safeGap\cf4 (cplex) : \cf10 0.0\cf4 ;\
\
        
\f1\b \cf7 if
\f0\b0 \cf4  (ok && (cplex.\cf14 getStatus\cf4 () == \cf13 IloAlgorithm\cf4 ::\cf14 Optimal\cf4  || cplex.\cf14 getStatus\cf4 () == \cf13 IloAlgorithm\cf4 ::\cf14 Feasible\cf4 )) \{\
            out.\cf14 feasible\cf4  = 
\f1\b \cf7 true
\f0\b0 \cf4 ;\
            out.\cf14 obj\cf4  = cplex.\cf14 getValue\cf4 (eta);\
\
            out.\cf14 seq\cf4 .\cf12 assign\cf4 (n, -\cf10 1\cf4 );\
            \cf14 extractSeqFromX\cf4 (cplex, x, out.\cf14 seq\cf4 );\
\
            out.\cf14 z\cf4 .\cf12 assign\cf4 (n, \cf10 0\cf4 );\
            
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  j = \cf10 0\cf4 ; j < n; j++) out.\cf14 z\cf4 [j] = (cplex.\cf14 getValue\cf4 (z[j]) > \cf10 0.5\cf4  ? \cf10 1\cf4  : \cf10 0\cf4 );\
\
            \cf2 // robust evaluation from extracted seq\cf4 \
            \cf13 SolveInfo\cf4  ev = \cf14 evalSequence\cf4 (jobs, out.\cf14 seq\cf4 );\
            out.\cf14 wTA\cf4  = ev.\cf14 wTA\cf4 ; out.\cf14 wTB\cf4  = ev.\cf14 wTB\cf4 ;\
            out.\cf14 obj\cf4  = ev.\cf14 obj\cf4 ;\
        \}\
\
        env.\cf14 end\cf4 ();\
    \} 
\f1\b \cf7 catch
\f0\b0 \cf4  (\cf13 IloException\cf4 & e) \{\
        out.\cf14 time\cf4  = \cf14 nowSec\cf4 () - t0;\
        out.\cf14 status\cf4  = \cf6 "Exception"\cf4 ;\
        out.\cf14 feasible\cf4  = 
\f1\b \cf7 false
\f0\b0 \cf4 ;\
        \cf12 cerr\cf4  << \cf6 "MIP-P exception: "\cf4  << e << \cf6 "\\n"\cf4 ;\
    \}\
    
\f1\b \cf7 return
\f0\b0 \cf4  out;\
\}\
\
\cf2 // ============================ TF/RDD instance generation ============================\cf4 \

\f1\b \cf7 static
\f0\b0 \cf4  \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > \cf11 genProcessingTimes\cf4 (
\f1\b \cf7 int
\f0\b0 \cf4  n, \cf8 mt19937\cf4 & rng) \{\
    \cf8 uniform_int_distribution\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > p_dist(\cf10 1\cf4 , \cf10 100\cf4 );\
    \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > p(n);\
    
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  i = \cf10 0\cf4 ; i < n; ++i) p[i] = p_dist(rng);\
    
\f1\b \cf7 return
\f0\b0 \cf4  p;\
\}\
\

\f1\b \cf7 static
\f0\b0 \cf4  \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > \cf11 genWeights\cf4 (
\f1\b \cf7 int
\f0\b0 \cf4  n, \cf8 mt19937\cf4 & rng) \{\
    \cf8 uniform_int_distribution\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > w_dist(\cf10 1\cf4 , \cf10 10\cf4 );\
    \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > w(n);\
    
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  i = \cf10 0\cf4 ; i < n; ++i) w[i] = w_dist(rng);\
    
\f1\b \cf7 return
\f0\b0 \cf4  w;\
\}\
\
\cf2 // Classical TF/RDD due date generator\cf4 \
\cf2 // d_j ~ U[ P*(1-TF-RDD/2), P*(1-TF+RDD/2) ], clipped into [0, P]\cf4 \

\f1\b \cf7 static
\f0\b0 \cf4  \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > \cf11 genDueDates_TF_RDD\cf4 (
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 >& p, 
\f1\b \cf7 double
\f0\b0 \cf4  TF, 
\f1\b \cf7 double
\f0\b0 \cf4  RDD, \cf8 mt19937\cf4 & rng) \{\
    
\f1\b \cf7 int
\f0\b0 \cf4  P = \cf12 accumulate\cf4 (p.\cf12 begin\cf4 (), p.\cf12 end\cf4 (), \cf10 0\cf4 );\
    
\f1\b \cf7 double
\f0\b0 \cf4  center = (
\f1\b \cf7 double
\f0\b0 \cf4 )P * (\cf10 1.0\cf4  - TF);\
    
\f1\b \cf7 double
\f0\b0 \cf4  half   = (
\f1\b \cf7 double
\f0\b0 \cf4 )P * (RDD / \cf10 2.0\cf4 );\
    
\f1\b \cf7 int
\f0\b0 \cf4  L = (
\f1\b \cf7 int
\f0\b0 \cf4 )\cf12 floor\cf4 (center - half);\
    
\f1\b \cf7 int
\f0\b0 \cf4  U = (
\f1\b \cf7 int
\f0\b0 \cf4 )\cf12 ceil\cf4 (center + half);\
    L = \cf12 max\cf4 (L, \cf10 0\cf4 );\
    U = \cf12 min\cf4 (U, P);\
    
\f1\b \cf7 if
\f0\b0 \cf4  (L > U) \cf12 swap\cf4 (L, U);\
    \cf8 uniform_int_distribution\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > d_dist(L, U);\
\
    \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > d(p.\cf12 size\cf4 ());\
    
\f1\b \cf7 for
\f0\b0 \cf4  (\cf8 size_t\cf4  i = \cf10 0\cf4 ; i < p.\cf12 size\cf4 (); ++i) d[i] = d_dist(rng);\
    
\f1\b \cf7 return
\f0\b0 \cf4  d;\
\}\
\

\f1\b \cf7 static
\f0\b0 \cf4  \cf8 vector\cf4 <\cf13 Job\cf4 > \cf11 generateInstance_TF_RDD\cf4 (
\f1\b \cf7 int
\f0\b0 \cf4  n, 
\f1\b \cf7 int
\f0\b0 \cf4  seed, 
\f1\b \cf7 double
\f0\b0 \cf4  TF, 
\f1\b \cf7 double
\f0\b0 \cf4  RDD) \{\
    \cf8 mt19937\cf4  rng(seed);\
    \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > p = \cf14 genProcessingTimes\cf4 (n, rng);\
    \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > w = \cf14 genWeights\cf4 (n, rng);\
    \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > d = \cf14 genDueDates_TF_RDD\cf4 (p, TF, RDD, rng);\
\
    \cf8 vector\cf4 <\cf13 Job\cf4 > jobs;\
    jobs.\cf12 reserve\cf4 (n);\
    
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  i = \cf10 0\cf4 ; i < n; ++i) \{\
        \cf13 Job\cf4  jb;\
        jb.\cf14 id\cf4  = i;\
        jb.\cf14 agent\cf4  = (i < n/\cf10 2\cf4 ) ? \cf10 0\cf4  : \cf10 1\cf4 ;\
        jb.\cf14 p\cf4  = p[i];\
        jb.\cf14 d\cf4  = d[i];\
        jb.\cf14 w\cf4  = w[i];\
        jobs.\cf12 push_back\cf4 (jb);\
    \}\
    
\f1\b \cf7 return
\f0\b0 \cf4  jobs;\
\}\
\
\cf2 // ---------------- Main comparison driver ----------------\cf4 \

\f1\b \cf7 int
\f0\b0 \cf4  \cf11 main\cf4 () \{\
    \cf12 cout\cf4  << \cf6 "=====================================================\\n"\cf4 ;\
    \cf12 cout\cf4  << \cf6 "MIP-P VI combination performance comparison\\n"\cf4 ;\
    \cf12 cout\cf4  << \cf6 "=====================================================\\n"\cf4 ;\
\
    \cf2 // EDIT output directory (macOS)\cf4 \
    \cf8 string\cf4  basePath = \cf6 "/Users/shijinwang/Desktop/MIP_P_VI_Compare"\cf4 ;\
    \cf12 system\cf4 ((\cf6 "mkdir -p \\""\cf4  + basePath + \cf6 "\\""\cf4 ).\cf12 c_str\cf4 ());\
    \cf12 cout\cf4  << \cf6 "Output directory: "\cf4  << basePath << \cf6 "\\n"\cf4 ;\
\
    \cf2 // Experiment settings\cf4 \
    \cf8 vector\cf4 <
\f1\b \cf7 int
\f0\b0 \cf4 > n_values = \{\cf10 15\cf4 \};      \cf2 // edit\cf4 \
    
\f1\b \cf7 int
\f0\b0 \cf4  instances_per_n = \cf10 10\cf4 ;        \cf2 // edit\cf4 \
    
\f1\b \cf7 double
\f0\b0 \cf4  TL = \cf10 1800.0\cf4 ;              \cf2 // seconds per run\cf4 \
   
\f1\b \cf7 double
\f0\b0 \cf4  TF = \cf10 0.6\cf4 ;\
    
\f1\b \cf7 double
\f0\b0 \cf4  RDD = \cf10 0.6\cf4 ;\
\
\
    \cf2 // Define VI combinations to compare\cf4 \
    \cf8 vector\cf4 <\cf8 pair\cf4 <\cf8 string\cf4 , \cf13 VIFlags\cf4 >> variants;\
\
    \cf2 // Minimal set (you can add/remove freely)\cf4 \
    variants.\cf12 push_back\cf4 (\{\cf6 "MIP-P (NONE)"\cf4 ,               \cf14 makeVIConfig\cf4 (
\f1\b \cf7 false
\f0\b0 \cf4 ,
\f1\b \cf7 false
\f0\b0 \cf4 ,
\f1\b \cf7 false
\f0\b0 \cf4 ,
\f1\b \cf7 false
\f0\b0 \cf4 ,
\f1\b \cf7 false
\f0\b0 \cf4 )\});\
    variants.\cf12 push_back\cf4 (\{\cf6 "MIP-P (VI1)"\cf4 ,                \cf14 makeVIConfig\cf4 (
\f1\b \cf7 true
\f0\b0 \cf4  ,
\f1\b \cf7 false
\f0\b0 \cf4 ,
\f1\b \cf7 false
\f0\b0 \cf4 ,
\f1\b \cf7 false
\f0\b0 \cf4 ,
\f1\b \cf7 false
\f0\b0 \cf4 )\});\
    variants.\cf12 push_back\cf4 (\{\cf6 "MIP-P (VI2)"\cf4 ,                \cf14 makeVIConfig\cf4 (
\f1\b \cf7 false
\f0\b0 \cf4 ,
\f1\b \cf7 true
\f0\b0 \cf4  ,
\f1\b \cf7 false
\f0\b0 \cf4 ,
\f1\b \cf7 false
\f0\b0 \cf4 ,
\f1\b \cf7 false
\f0\b0 \cf4 )\});\
    variants.\cf12 push_back\cf4 (\{\cf6 "MIP-P (VI1+VI2)"\cf4 ,            \cf14 makeVIConfig\cf4 (
\f1\b \cf7 true
\f0\b0 \cf4  ,
\f1\b \cf7 true
\f0\b0 \cf4  ,
\f1\b \cf7 false
\f0\b0 \cf4 ,
\f1\b \cf7 false
\f0\b0 \cf4 ,
\f1\b \cf7 false
\f0\b0 \cf4 )\});\
    variants.\cf12 push_back\cf4 (\{\cf6 "MIP-P (VI3)"\cf4 ,                \cf14 makeVIConfig\cf4 (
\f1\b \cf7 false
\f0\b0 \cf4 ,
\f1\b \cf7 false
\f0\b0 \cf4 ,
\f1\b \cf7 true
\f0\b0 \cf4  ,
\f1\b \cf7 false
\f0\b0 \cf4 ,
\f1\b \cf7 false
\f0\b0 \cf4 )\});\
    variants.\cf12 push_back\cf4 (\{\cf6 "MIP-P (VI4)"\cf4 ,                \cf14 makeVIConfig\cf4 (
\f1\b \cf7 false
\f0\b0 \cf4 ,
\f1\b \cf7 false
\f0\b0 \cf4 ,
\f1\b \cf7 false
\f0\b0 \cf4 ,
\f1\b \cf7 true
\f0\b0 \cf4  ,
\f1\b \cf7 false
\f0\b0 \cf4 )\});\
    variants.\cf12 push_back\cf4 (\{\cf6 "MIP-P (VI5)"\cf4 ,                \cf14 makeVIConfig\cf4 (
\f1\b \cf7 false
\f0\b0 \cf4 ,
\f1\b \cf7 false
\f0\b0 \cf4 ,
\f1\b \cf7 false
\f0\b0 \cf4 ,
\f1\b \cf7 false
\f0\b0 \cf4 ,
\f1\b \cf7 true
\f0\b0 \cf4  )\});\
    variants.\cf12 push_back\cf4 (\{\cf6 "MIP-P (VI3+VI4+VI5)"\cf4 ,        \cf14 makeVIConfig\cf4 (
\f1\b \cf7 false
\f0\b0 \cf4 ,
\f1\b \cf7 false
\f0\b0 \cf4 ,
\f1\b \cf7 true
\f0\b0 \cf4  ,
\f1\b \cf7 true
\f0\b0 \cf4  ,
\f1\b \cf7 true
\f0\b0 \cf4  )\});\
    variants.\cf12 push_back\cf4 (\{\cf6 "MIP-P (ALL VI1..VI5)"\cf4 ,       \cf14 makeVIConfig\cf4 (
\f1\b \cf7 true
\f0\b0 \cf4  ,
\f1\b \cf7 true
\f0\b0 \cf4  ,
\f1\b \cf7 true
\f0\b0 \cf4  ,
\f1\b \cf7 true
\f0\b0 \cf4  ,
\f1\b \cf7 true
\f0\b0 \cf4  )\});\
    variants.\cf12 push_back\cf4 (\{\cf6 "MIP-P (VI1,VI5)"\cf4 ,       \cf14 makeVIConfig\cf4 (
\f1\b \cf7 true
\f0\b0 \cf4  ,
\f1\b \cf7 false
\f0\b0 \cf4  ,
\f1\b \cf7 false
\f0\b0 \cf4  ,
\f1\b \cf7 false
\f0\b0 \cf4  ,
\f1\b \cf7 true
\f0\b0 \cf4  )\});\
    variants.\cf12 push_back\cf4 (\{\cf6 "MIP-P (VI1,VI4)"\cf4 ,       \cf14 makeVIConfig\cf4 (
\f1\b \cf7 true
\f0\b0 \cf4  ,
\f1\b \cf7 false
\f0\b0 \cf4  ,
\f1\b \cf7 false
\f0\b0 \cf4  ,
\f1\b \cf7 true
\f0\b0 \cf4  ,
\f1\b \cf7 false
\f0\b0 \cf4  )\});\
\
    \cf2 // Summary CSV\cf4 \
    \cf8 string\cf4  csvPath = basePath + \cf6 "/results_summary.csv"\cf4 ;\
    \cf8 ofstream\cf4  csv(csvPath.\cf12 c_str\cf4 ());\
\
    \cf2 // Header\cf4 \
    csv << \cf6 "n,inst,U_min,UB_eta"\cf4 ;\
    
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 auto
\f0\b0 \cf4  &kv : variants) \{\
        \cf2 // safe compact column name\cf4 \
        \cf8 string\cf4  name = kv.\cf12 first\cf4 ;\
        \cf2 // replace spaces/parentheses/plus to keep CSV readable\cf4 \
        
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 char
\f0\b0 \cf4  &c : name) \{\
            
\f1\b \cf7 if
\f0\b0 \cf4  (c == \cf10 ' '\cf4 ) c = \cf10 '_'\cf4 ;\
            
\f1\b \cf7 if
\f0\b0 \cf4  (c == \cf10 '('\cf4  || c == \cf10 ')'\cf4  ) c = \cf10 '_'\cf4 ;\
            
\f1\b \cf7 if
\f0\b0 \cf4  (c == \cf10 '+'\cf4 ) c = \cf10 '_'\cf4 ;\
        \}\
        csv << \cf6 ","\cf4  << name << \cf6 "_status"\cf4 \
            << \cf6 ","\cf4  << name << \cf6 "_eta"\cf4 \
            << \cf6 ","\cf4  << name << \cf6 "_time"\cf4 \
            << \cf6 ","\cf4  << name << \cf6 "_gap"\cf4 ;\
    \}\
    csv << \cf6 "\\n"\cf4 ;\
\
    
\f1\b \cf7 int
\f0\b0 \cf4  seedBase = \cf10 12345\cf4 ;\
\
    
\f1\b \cf7 for
\f0\b0 \cf4  (\cf8 size_t\cf4  ni = \cf10 0\cf4 ; ni < n_values.\cf12 size\cf4 (); ni++) \{\
        
\f1\b \cf7 int
\f0\b0 \cf4  n = n_values[ni];\
        \cf12 cout\cf4  << \cf6 "\\n==== n="\cf4  << n << \cf6 " ====\\n"\cf4 ;\
\
        
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 int
\f0\b0 \cf4  inst = \cf10 0\cf4 ; inst < instances_per_n; inst++) \{\
            \cf12 cout\cf4  << \cf6 "\\n-- instance "\cf4  << inst << \cf6 " --\\n"\cf4 ;\
\
            \cf8 vector\cf4 <\cf13 Job\cf4 > jobs = \cf14 generateInstance_TF_RDD\cf4 (n, seedBase + inst * \cf10 100\cf4  + n * \cf10 10000\cf4 , TF, RDD);\
\
            \cf2 // save raw instance\cf4 \
            \cf14 saveInstanceCSV\cf4 (basePath + \cf6 "/instance_n"\cf4  + \cf12 to_string\cf4 (n) + \cf6 "_i"\cf4  + \cf12 to_string\cf4 (inst) + \cf6 ".csv"\cf4 , jobs);\
\
            \cf2 // Moore -> U_min and UB\cf4 \
            
\f1\b \cf7 auto
\f0\b0 \cf4  mo = \cf14 mooresAlgorithm\cf4 (jobs);\
            
\f1\b \cf7 int
\f0\b0 \cf4  U_min = mo.\cf12 first\cf4 ;\
            \cf13 SolveInfo\cf4  moMet = \cf14 evalSequence\cf4 (jobs, mo.\cf12 second\cf4 );\
            
\f1\b \cf7 double
\f0\b0 \cf4  UB_eta = moMet.\cf14 obj\cf4 ;\
\
            \cf12 cout\cf4  << \cf6 "U_min="\cf4  << U_min << \cf6 " UB_eta(Moore)="\cf4  << UB_eta << \cf6 "\\n"\cf4 ;\
\
            \cf2 // detail log\cf4 \
            \cf8 string\cf4  logPath = basePath + \cf6 "/detail_n"\cf4  + \cf12 to_string\cf4 (n) + \cf6 "_i"\cf4  + \cf12 to_string\cf4 (inst) + \cf6 ".txt"\cf4 ;\
            \cf8 ofstream\cf4  lf(logPath.\cf12 c_str\cf4 ());\
            lf << \cf6 "Instance n="\cf4  << n << \cf6 " inst="\cf4  << inst << \cf6 "\\n"\cf4 ;\
            lf << \cf6 "U_min="\cf4  << U_min << \cf6 " UB_eta="\cf4  << UB_eta << \cf6 "\\n\\n"\cf4 ;\
            \cf14 writeMethodLog\cf4 (lf, \cf6 "Moore(UB)"\cf4 , moMet);\
\
            \cf2 // run all variants\cf4 \
            \cf8 vector\cf4 <\cf13 SolveInfo\cf4 > results;\
            results.\cf12 reserve\cf4 (variants.\cf12 size\cf4 ());\
\
            
\f1\b \cf7 for
\f0\b0 \cf4  (
\f1\b \cf7 auto
\f0\b0 \cf4  &kv : variants) \{\
                
\f1\b \cf7 const
\f0\b0 \cf4  \cf8 string\cf4 & name = kv.\cf12 first\cf4 ;\
                
\f1\b \cf7 const
\f0\b0 \cf4  \cf13 VIFlags\cf4 & vf = kv.\cf12 second\cf4 ;\
\
                \cf13 SolveInfo\cf4  res = \cf14 solveMIP_P_withVIFlags\cf4 (jobs, U_min, UB_eta, TL, vf);\
\
                \cf12 cout\cf4  << \cf12 setw\cf4 (\cf10 28\cf4 ) << \cf12 left\cf4  << name\
                     << \cf6 " status="\cf4  << \cf12 setw\cf4 (\cf10 10\cf4 ) << res.\cf14 status\cf4 \
                     << \cf6 " eta="\cf4  << \cf12 setw\cf4 (\cf10 10\cf4 ) << res.\cf14 obj\cf4 \
                     << \cf6 " time="\cf4  << \cf12 setw\cf4 (\cf10 10\cf4 ) << res.\cf14 time\cf4 \
                     << \cf6 " gap="\cf4  << res.\cf14 gap\cf4  << \cf6 "\\n"\cf4 ;\
\
                \cf14 writeMethodLog\cf4 (lf, name, res);\
                results.\cf12 push_back\cf4 (res);\
            \}\
\
            lf.\cf12 close\cf4 ();\
\
            \cf2 // summary row\cf4 \
            csv << n << \cf6 ","\cf4  << inst << \cf6 ","\cf4  << U_min << \cf6 ","\cf4  << UB_eta;\
            
\f1\b \cf7 for
\f0\b0 \cf4  (\cf8 size_t\cf4  k = \cf10 0\cf4 ; k < results.\cf12 size\cf4 (); k++) \{\
                csv << \cf6 ","\cf4  << results[k].\cf14 status\cf4 \
                    << \cf6 ","\cf4  << results[k].\cf14 obj\cf4 \
                    << \cf6 ","\cf4  << results[k].\cf14 time\cf4 \
                    << \cf6 ","\cf4  << results[k].\cf14 gap\cf4 ;\
            \}\
            csv << \cf6 "\\n"\cf4 ;\
        \}\
    \}\
\
    csv.\cf12 close\cf4 ();\
    \cf12 cout\cf4  << \cf6 "\\nDONE. Summary CSV:\\n  "\cf4  << csvPath << \cf6 "\\n"\cf4 ;\
    
\f1\b \cf7 return
\f0\b0 \cf4  \cf10 0\cf4 ;\
\}\
}